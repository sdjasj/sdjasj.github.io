<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021秋计组理论复习</title>
    <url>/2022/02/07/2021%E7%A7%8B%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="CPI（Clock-cycle-Per-Instruction）表示每条计算机指令执行所需的时钟周期">CPI（Clock cycle Per Instruction）表示每条计算机指令执行所需的时钟周期</h4>
<h1>Cache</h1>
<h3 id="主存地址结构：TIO">主存地址结构：TIO</h3>
<p>CPU发出的主存地址  Tag(剩余位数) Index(位数由cache块数决定) Offset(位数由块大小决定)</p>
<h3 id="直接映射cache的容量">直接映射cache的容量</h3>
<p>❑ 一个cache块不仅包含数据，还包含tag、valid等</p>
<p>❑ 数据位：8× $2^O$  位</p>
<p>❑ Tag位：主存地址位数–Index位数–Offset位数<br>
❑ Valid位：1位，指示cache块是否包含有效数据<br>
❑ Cache总容量 = cache块数×(数据位 + Tag位数 + Valid位数)<br>
= $2^{Index}$  ×(8×$2^{Offset}$  +Tag+1)位</p>
<span id="more"></span>
<h3 id="Cache效率参数：最大化命中，最小化缺失">Cache效率参数：最大化命中，最小化缺失</h3>
<p>◆ 命中率（Hit Rate，HR）</p>
<p>对于一段程序，命中次数占总存储访问次数的比例</p>
<p>◆ 缺失率（Miss Rate，MR）</p>
<p>对于一段程序，缺失次数占总存储访问次数的比例</p>
<p>❑ HR与MR恒满足𝐻𝑅 + 𝑀𝑅 =1</p>
<h3 id="Cache延迟参数">Cache延迟参数</h3>
<p>◆ 命中时间（Hit time，HT）</p>
<p>访问cache的时间（包含了tag比较时间）</p>
<p>◆ 缺失代价（Miss penalty，MP）</p>
<p>从下一层存储器读入一个cache块的时间</p>
<h3 id="Cache命中—写命中-D">Cache命中—写命中(D$)</h3>
<p>◆ 1）写通(Write-Through)：总是同时写cache与主存</p>
<p>⚫ cache与主存总是一致的</p>
<p>⚫ 慢！写的性能就是主存的性能</p>
<p>⚫ 改善措施：可以与cache平行部署一个Write Buffer</p>
<p>2）写回(Write-Back)：只写cache，当cache块需要被替换时再更新主存</p>
<p>⚫ 这意味着cache与主存之间是可以不一致的</p>
<p>⚫ 命中在同一cache块的多个写被收集起来了，提高了写的效率</p>
<p>⚫ Dirty位：每个cache块需要增加一个dirty为，用于记录是否被写入过，即在替换时需要写回到主存</p>
<h3 id="写缺失（D-）">写缺失（D$）</h3>
<p>◆ 写分配（write allocate）： 流水线暂停；</p>
<p>从主存读入block；</p>
<p>写入cache；</p>
<p>执行写命中</p>
<p>⚫ 无论写通还是写回，写分配均有效</p>
<p>⚫ 可以确保在写缺失后，cache有最新数据</p>
<p>◆ 非写分配（No-write allocate）：不写cache而直接写主存</p>
<p>⚫ cache不包含最新数据</p>
<p>⚫ 但主存包含最新数据</p>
<h3 id="Cache的AMAT">Cache的AMAT</h3>
<p>平均存储器访问时间(Average Memory Access Time，AMAT)：综合考虑命中和缺失后的存储器访问的平均延迟</p>
<p>平均存储器访问时间 = 命中时间 + 缺失率×缺失代价	(缩写：AMAT = HT + MR × MP)</p>
<h3 id="Cache对CPI的影响">Cache对CPI的影响</h3>
<p>❑ CPU性能</p>
<p>𝐶𝑃𝑈时间 = 指令数 × CPI × 时钟周期时间</p>
<p>❑ 考虑存储器访问延迟的CPI</p>
<p>𝐶𝑃𝐼<sub>stall</sub>   = 𝐶𝑃𝐼<sub>base</sub>+ 平均存储延迟周期</p>
<p>❑ 存储延迟周期</p>
<p>存储延迟周期 = $\frac{访存次数}{指令}$  × 𝑀𝑅 × 𝑀<em>P</em></p>
<h3 id="多级cache的AMAT-平均存储器访问时间">多级cache的AMAT(平均存储器访问时间 )</h3>
<p>❑ AMAT = L1 HT + L1 MR × L1 MP</p>
<p>◆ 现在L1 MP依赖于L2的性能</p>
<p>❑ L1 MP = L2 HT + L2 MR × L2 MP</p>
<p>◆ 如果有更多层次，则继续迭代</p>
<p>MP<sub>i</sub>   = HT<sub>i+1</sub> + MR<sub>i+1</sub> × MP<sub>i+1</sub></p>
<p>◆ 最后一层就是主存的访问时间</p>
<p>❑ 对于2级cache</p>
<p>AMAT = L1 HT + L1 MR × (L2 HT + L2 MR × L2 MP)</p>
<p>局部缺失率 vs. 全局缺失率</p>
<p>❑ 局部缺失率（Local miss rate）：对于某层cache的访问而产生的</p>
<h3 id="缺失比例">缺失比例</h3>
<p>◆ 例如：L2$局部缺失率 = L2$缺失次数/L1$缺失次数</p>
<p>❑ 全局缺失率（Global miss rate）：对于所有各级cache的访问而产生的缺失比例</p>
<p>◆ 这事实上是整个存储层次的总体性能参数</p>
<p>❑ 对于N级cache来说，全局缺失率有两种计算方法：</p>
<p>◆ 方法1： 全局缺失率 =  $\prod{Li}$ 局部缺失率</p>
<p>◆ 方法2：全局缺失率 = Ln缺失次数/L1访问次数</p>
<p>❑ 根据定义可知，全局MR ≤ 任意的局部MR</p>
<h3 id="更全面的性能计算公式">更全面的性能计算公式</h3>
<p>❑ 对于2级cache，我们知道：</p>
<p>MRglobal = L1 MR × L2 MR</p>
<p>❑ AMAT：</p>
<p>AMAT = L1 HT + L1 MR × (L2 HT + L2 MR × L2 MP)</p>
<p>AMAT = L1 HT + L1 MR × L2 HT + MRglobal × L2 MP</p>
<p>❑ CPI：</p>
<p>𝐶𝑃𝐼stall = 𝐶𝑃𝐼𝑏𝑎𝑠𝑒 + 访存 指令/次数 × 𝐿1𝑀𝑅 × (𝐿2 HT + 𝐿2 𝑀𝑅 × 𝐿2 𝑀𝑃)</p>
<p>𝐶𝑃𝐼stall = 𝐶𝑃𝐼𝑏𝑎𝑠𝑒 + 访存次数/指令 × (𝐿1𝑀𝑅 × 𝐿2 HT + 𝑀𝑅𝐺lobal × 𝐿2 𝑀𝑃)</p>
<h5 id="页表项（page-table-entry）">页表项（page table entry）</h5>
<h5 id="虚页号-virtural-page-number，VPN">虚页号(virtural page number，VPN)</h5>
<h5 id="物理页号-physical-page-number，PPN">物理页号(physical page number，PPN)</h5>
<h5 id="页表（page-table，PT）">页表（page table，PT）</h5>
<h3 id="虚存系统的重要概念：页表项扩展">虚存系统的重要概念：页表项扩展</h3>
<p>❑ 由于引入了硬盘，因此一个虚页面可能存储在磁盘上，也可能已经装载到主存（某个物理页面）</p>
<p>❑ 因此，PTE不仅需要记录PPN，也需要记录相应的磁盘地址</p>
<p>◆ 这里用DPx代表存储在硬盘上的页面x的磁盘地址</p>
<p>页表在主存中的起始地址保存在  <strong>页表基地址寄存器</strong></p>
<h4 id="VA地址分割为-虚页号-virtural-page-number，VPN-，页内偏移-page-offset">VA地址分割为 虚页号(virtural page number，VPN)，页内偏移(page offset)</h4>
<h4 id="PA地址分割为-物理页号-physical-page-number，PPN-，页内偏移-page-offset">PA地址分割为 物理页号(physical page number，PPN)，页内偏移(page offset)</h4>
<h4 id="VA利用虚页号寻址页表">VA利用虚页号寻址页表</h4>
<h4 id="存放系统程序或者各类常数使用ROM芯片，存放用户程序选用RAM芯片">存放系统程序或者各类常数使用ROM芯片，存放用户程序选用RAM芯片</h4>
<h4 id="存储容量-末地址-1-首地址">存储容量 = 末地址+1-首地址</h4>
<h4 id="部分译码即只用高位地址的一部分参与译码，而另一部分高位地址与译码电路无关，因此出现一个存储单元对应多个地址的现象，这种现象称为地址重叠-如00111和01111，前两位不参与译码，导致一个存储单元对应多个地址">部分译码即只用高位地址的一部分参与译码，而另一部分高位地址与译码电路无关，因此出现一个存储单元对应多个地址的现象，这种现象称为地址重叠(如00111和01111，前两位不参与译码，导致一个存储单元对应多个地址)</h4>
<h4 id="所有DRAM芯片同时刷新，由刷新计数器自动计数，按行刷新-只需行地址-，对CPU透明。-所有芯片一起刷新，只和单个芯片多少行有关">所有DRAM芯片同时刷新，由刷新计数器自动计数，按行刷新(只需行地址)，对CPU透明。(所有芯片一起刷新，只和单个芯片多少行有关)</h4>
<h4 id="读-写行地址和刷新行地址被送到一个多路选择器，由内部控制电路选择哪个地址被送到行译码器">读/写行地址和刷新行地址被送到一个多路选择器，由内部控制电路选择哪个地址被送到行译码器</h4>
<h4 id="刷新就是读。按行刷新，每次刷新1行">刷新就是读。按行刷新，每次刷新1行</h4>
<h4 id="刷新地址计数器位数-行地址位数">刷新地址计数器位数 = 行地址位数</h4>
<h4 id="刷新间隔-刷新周期">刷新间隔 = 刷新周期</h4>
<h4 id="DRAM芯片封装的特殊：行列地址管脚复用，因此行列地址线为存储单元log2的一半">DRAM芯片封装的特殊：行列地址管脚复用，因此行列地址线为存储单元log2的一半</h4>
<h4 id="JK触发器的通用特性方程：1">JK触发器的通用特性方程：<img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5C2021%E7%A7%8B%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0%5C1.png" alt="1"></h4>
<h2 id="MIPS">MIPS</h2>
<p><strong>形式地址与有效地址</strong></p>
<p>Ø 形式地址：指令中直接给出的地址编码</p>
<p>Ø 有效地址：根据形式地址和寻址方式计算出来的操作数在内存单元</p>
<p>中的地址</p>
<p>Ø 寻址方式：根据形式地址计算到操作数的有效地址的方式（算法）</p>
<h5 id="寻址方式-立即寻址-addi-、寄存器寻址-add-、基址寻址-lw-、PC相对寻址-beq-、伪直接寻址-j">寻址方式:立即寻址(addi)、寄存器寻址(add)、基址寻址(lw)、PC相对寻址(beq)、伪直接寻址(j)</h5>
<h2 id="流水线">流水线</h2>
<h4 id="流水线加速比">流水线加速比</h4>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5C2021%E7%A7%8B%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0%5C2.png" alt="2"></p>
<ul>
<li>
<p>潜在加速比 = 流水线级数 (假设单周期数据通路切分为P段，且各段延迟均相等，则流水线性能是单周期的P倍！ )</p>
</li>
<li>
<p>流水段执行时间不平衡，则加速比下降</p>
</li>
<li>
<p>填充流水线和排放流水线，导致加速比下降</p>
</li>
<li>
<p>流水线不改善单条指令执行周期数</p>
</li>
<li>
<p>流水线改善的是吞吐率</p>
</li>
<li>
<p>理论上，当流水线充满后，每个时钟周期可以执行完一条指令</p>
</li>
<li>
<p>流水线时钟频率受限于最慢的流水段</p>
</li>
</ul>
<h4 id="流水线冒险（流水线相近指令-出现某些关联，下一个时钟周期不能执行下一条指令，指令流水线必须出现停顿）">流水线冒险（流水线相近指令 出现某些关联，下一个时钟周期不能执行下一条指令，指令流水线必须出现停顿）</h4>
<h5 id="结构冒险（structural-hazard）：需要的资源被占用">结构冒险（structural hazard）：需要的资源被占用</h5>
<p>硬件不支持多条指令在同一个时钟周期执行。若系统只有一个存储器部件， 就会带来结构冒险问题，例如：lw/sw指令执行需要访问存储器，指令取指阶段需要访问存储器，将出现存储器使用冲突</p>
<h5 id="数据冒险（data-hazard）：指令之间存在数据依赖">数据冒险（data hazard）：指令之间存在数据依赖</h5>
<p>指令执行所需的数据暂时不可用，后继指令需要等待前序指令执行结束，从而造成的指令执行停顿，数据冒险一般发生在相近指令共用一个存储单元或寄存器时</p>
<h5 id="控制冒险（control-hazard）：也称为分支冒险（branch-hazard）">控制冒险（control hazard）：也称为分支冒险（branch hazard）</h5>
<p>指令流的方向选择依赖于前序指令执行结果，必须根据前一条指令的执行结果才能确定下一条真正要执行的指令，此时流水线中取得的可能不是真正要执行的指令</p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5C2021%E7%A7%8B%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0%5C3.png" alt="3"></p>
<h2 id="I-O">I/O</h2>
<ul>
<li>外部设备并不直接挂接在系统总线上,而是通过I/O接口为桥梁实现与系统总线的连接</li>
</ul>
<h4 id="DMA（Direct-Memory-Access">DMA（Direct Memory Access)</h4>
<ul>
<li>
<p>CPU对总线的控制被临时禁止。DMA控制器接管总线控制权，控制数据直接在存储器与外设之间高速交换</p>
</li>
<li>
<p>CPU不再介入具体的I/O操作，由DMA控制器来负责提供存储器地址信号、读写控制信号等。</p>
</li>
<li>
<p>CPU与I/O设备在更大的程度上并行工作，效率更高。</p>
</li>
<li>
<p>DMA方式适合高速批量的数据传输，如视频显示刷新、磁盘存储系统的读写，存储器到存储器的传输等</p>
</li>
<li>
<h5 id="CPU仅在开始DMA操作之前和完成DMA操作之后参与I-O处理，在DMA过程中，CPU可以运行原来的程序">CPU仅在开始DMA操作之前和完成DMA操作之后参与I/O处理，在DMA过程中，CPU可以运行原来的程序</h5>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA高工20级数据结构考题回忆版</title>
    <url>/2022/02/03/BUAA%E9%AB%98%E5%B7%A520%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E9%A2%98%E5%9B%9E%E5%BF%86%E7%89%88/</url>
    <content><![CDATA[<h1>判断(2分一题)</h1>
<p>1.N个结点的树分有N-1条边</p>
<p>2.Python向下兼容性很好</p>
<p>3.兄弟伙伴算法分配内存速度很快</p>
<p>4.冒泡排序不稳定，快速排序稳定</p>
<p>5.一个字符串字母出现次数全不相同，字母的哈夫曼编码唯一</p>
<p>6.树的后序遍历和转化成二叉树的中序遍历结果相同</p>
<p>(只记得6道了，但其他应该很简单，秒选那种，所以没啥印象)</p>
<span id="more"></span>
<h1>问答</h1>
<p>数据结构常见的操作（5分</p>
<p>给稀疏矩阵，画三元组存储结构和十字链表存储结构（8</p>
<p>给中序后序遍历序列，画中序后序线索二叉树</p>
<p>详细说明并举例B_树插入删除</p>
<h1>代码</h1>
<p>详细说明LL LR失衡原因并给出LL LR旋转代码(20)</p>
<p>非递归堆排序代码，可以用sstack类(20)</p>
<p>(做梦也没想到会考这个，还好我记得)</p>
<h1>总结</h1>
<p>数据结构考试整份卷子一个图的算法都没有，考得又偏又怪。想拿到好成绩唯一办法就是把老师所有PPT背一遍，建议不要面向往年题复习，题目方向差异较大(19年考了KMP 最小生成树 AOE，而20年完全没有涉及图)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2022/02/14/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="简单使用">简单使用</h2>
<h3 id="初始化用户名">初始化用户名</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="创建仓库">创建仓库</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></div>
<span id="more"></span>
<h3 id="添加文件到仓库">添加文件到仓库</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add filename <span class="comment">#添加到暂存区</span></span><br></pre></td></tr></table></figure></div>
<h3 id="文件提交到仓库">文件提交到仓库</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;本次提交的说明，可以输入任意内容&quot;</span>   <span class="comment">#将暂存区文件添加到master的分支</span></span><br></pre></td></tr></table></figure></div>
<h2 id="管理文件">管理文件</h2>
<h3 id="历史记录">历史记录</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> [分支名] 查看某分支的提交历史，不写分支名查看当前所在分支</span><br><span class="line">git <span class="built_in">log</span> --oneline 一行显示提交历史</span><br><span class="line">git <span class="built_in">log</span> -n 其中 n 是数字，查看最近 n 个提交</span><br><span class="line">git <span class="built_in">log</span> --author [贡献者名字] 查看指定贡献者的提交记录</span><br><span class="line">git <span class="built_in">log</span> --graph 图示法显示提交历史</span><br></pre></td></tr></table></figure></div>
<h3 id="版本回退">版本回退</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#版本回退是针对整个仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#HEAD^回退一个版本 HEAD^^回退两个版本...以此类推 Head~100回退100个版本</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"><span class="comment">#1094a是commit_id,指定commit_id回到未来版本</span></span><br><span class="line">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure></div>
<h3 id="查看历史命令">查看历史命令</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#帮助查看commitid回到未来版本</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></div>
<h3 id="撤销修改">撤销修改</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#撤销修改针对某个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</span></span><br><span class="line"><span class="comment">#一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态</span></span><br><span class="line">$ git checkout -- file</span><br><span class="line"></span><br><span class="line"><span class="comment">#已经把文件提交到暂存区</span></span><br><span class="line"><span class="comment">##把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"><span class="comment">##再撤销工作区文件修改</span></span><br><span class="line">$ git checkout -- file</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将工作区的xxx回滚到暂存区中的xxx</span></span><br><span class="line">git restore xxx</span><br><span class="line"><span class="comment"># 撤销暂存区中的xxx的修改</span></span><br><span class="line">git restore --staged xxx</span><br></pre></td></tr></table></figure></div>
<h3 id="删除文件">删除文件</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将文件从暂存区和工作区中删除</span></span><br><span class="line">$ git rm &lt;file&gt;</span><br><span class="line"><span class="comment">#如果再commit了</span></span><br><span class="line">$ git commit</span><br><span class="line"><span class="comment">#也可以恢复</span></span><br><span class="line"><span class="comment">#$ git reset --hard HEAD^ 回退到上个版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暂存区指定的文件替换工作区的文件</span></span><br><span class="line">$ git checkout -- filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接从暂存区删除文件，工作区则不做出改变</span></span><br><span class="line">git rm --cached &lt;file&gt;” </span><br><span class="line"></span><br><span class="line"><span class="comment">#会用 HEAD 指向的 master 分支中的指定文件替换暂存区文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</span></span><br><span class="line">git reset HEAD &lt;file&gt; <span class="comment">#再用git checkout --filename暂存区指定文件替换工作区文件</span></span><br><span class="line"><span class="comment">#清除工作区未跟踪文件</span></span><br><span class="line">git clean &lt;file&gt; -f</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="远程仓库">远程仓库</h2>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程仓库&gt; &lt;分支名&gt;#本地仓库提交到远程仓库</span><br><span class="line">加了参数-u后，以后即可直接用git push 代替git push origin master</span><br><span class="line">git push -u origin master </span><br><span class="line">git pull #远程仓库更新到本地</span><br><span class="line">git remote #查看远程仓库名字，防止忘了</span><br><span class="line">git clone + [仓库地址] #克隆前面在 GitHub 上创建的仓库</span><br><span class="line">git status #查看整个仓库的状态</span><br><span class="line">git remote add &lt;远程仓库名字，一般为origin&gt; git@github.com:michaelliao/learngit.git #添加远程仓库</span><br></pre></td></tr></table></figure></div>
<h2 id="分支">分支</h2>
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针</p>
<p>Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针，指向当前所在的本地分支（将 <code>HEAD</code> 想象为当前分支的别名）</p>
<p>分支切换改变的是HEAD所指向的分支</p>
<p>所有分支共用一个暂存区，commit的时候看在哪个分支就把节点加到哪个分支后面</p>
<h3 id="创建与合并分支">创建与合并分支</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;分支名&gt; <span class="comment">#创建分支</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;分支名&gt; <span class="comment">#切换分支</span></span><br><span class="line"><span class="comment">######上述两条命令等价于git checkout -b &lt;分支名&gt;</span></span><br><span class="line"></span><br><span class="line">git branch <span class="comment">#列出所有分支，当前分支前面会标一个*号</span></span><br><span class="line"></span><br><span class="line">git branch -D &lt;分支&gt; <span class="comment">#删除分支</span></span><br><span class="line"></span><br><span class="line">git branch -m &lt;分支1&gt; &lt;分支2&gt; 把分支1重命名为分支2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的远程与本地分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line">git merge &lt;指定分支&gt; <span class="comment">#合并指定分支到当前分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看每一个分支的最后一次提交</span></span><br><span class="line">git branch -v</span><br></pre></td></tr></table></figure></div>
<p><strong>分支切换会改变你工作目录中的文件</strong></p>
<p>​	在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样</p>
<p><strong>切换分支遇到冲突</strong></p>
<p>原因:当前分支工作区或暂存区有文件没有commit</p>
<p>解决办法:当前分支先commit再切换分支</p>
<h3 id="解决冲突">解决冲突</h3>
<p>1.当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<p>2.当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p><strong>步骤</strong>：</p>
<p>1.根据git status看哪里有冲突，去修改</p>
<p>2.将修改完的文件git add</p>
<p>3.修改完所有冲突后git commit</p>
<h3 id="分支管理">分支管理</h3>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> &lt;指定分支&gt;</span><br></pre></td></tr></table></figure></div>
<h3 id="修复bug">修复bug</h3>
<p>当前分支还没提交，想修复另一个分支的bug时</p>
<p>1.<code>git stash</code> 保存工作现场</p>
<p>2.<code>git stash pop</code>恢复工作现场</p>
<p>3.<code>git cherry-pick &lt;commit&gt;</code> 把bug提交的修改“复制”到当前分支，避免重复劳动</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程预习</title>
    <url>/2022/02/10/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%84%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ul>
<li>一个任务通常就是一个程序，每个运行中的程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程</li>
<li>归纳起来可以这样说∶操作系统可以同时执行多个任务，每个任务就是进程;进程可以同时执行多个任务，每个任务就是线程。</li>
</ul>
<span id="more"></span>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote>
<p>并发性（concurrency）和并行性（parallel）是两个概念，并行指在同一时刻，有多条指令在多个处理器上同时执行;并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</p>
</blockquote>
<h2 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h2><h3 id="三种创建线程的方法："><a href="#三种创建线程的方法：" class="headerlink" title="三种创建线程的方法："></a>三种创建线程的方法：</h3><ul>
<li><h4 id="通过实现-Runnable-接口；"><a href="#通过实现-Runnable-接口；" class="headerlink" title="通过实现 Runnable 接口；"></a>通过实现 Runnable 接口；</h4></li>
</ul>
<h5 id="实现-Runnable-接口来创建并启动多线程的步骤如下"><a href="#实现-Runnable-接口来创建并启动多线程的步骤如下" class="headerlink" title="实现 Runnable 接口来创建并启动多线程的步骤如下"></a>实现 Runnable 接口来创建并启动多线程的步骤如下</h5><p> 1.定义Runnable 接口的实现类，并重写该接口的 run方法，该run方法的方法体同样是该线程的线程执行体。</p>
<p>2.创建 Runnable 实现类的实例，并以此实例作为Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">SecThread sc = <span class="keyword">new</span> SecThread() <span class="comment">//SecThread类实现Runnable接口</span></span><br><span class="line"><span class="keyword">new</span> Thread(sc).start() <span class="comment">//以sc建立新线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(sc,<span class="string">&#x27;lbh666&#x27;</span>) <span class="comment">//创建线程时指定名字</span></span><br></pre></td></tr></table></figure></div>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1.采用Runnable 接口的方式创建的多个线程可以共享线程类的实例变量。这是因为在这种方式下，程序所创建的 Runnable 对象只是线程的 target，而多个线程可以共享同一个target，所以多个线程可以共享同一个线程类的实例变量</p>
<p>2.可用lambda表达式创建Runnable对象，因为Runnable是一个函数式接口</p>
<p>3.执行start()方法的顺序不代表线程启动的顺序</p>
<ul>
<li><h4 id="通过继承-Thread-类本身"><a href="#通过继承-Thread-类本身" class="headerlink" title="通过继承 Thread 类本身"></a>通过继承 Thread 类本身</h4></li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="E:\待更新博客\新建文件夹\JAVA多线程预习\image-20220209151412300.png" alt="image-20220209151412300"></p>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><p><strong>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</strong></p>
<ul>
<li><h4 id="通过-Callable-和-Future-创建线程。"><a href="#通过-Callable-和-Future-创建线程。" class="headerlink" title="通过 Callable 和 Future 创建线程。"></a>通过 Callable 和 Future 创建线程。</h4></li>
</ul>
<h5 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h5><p>1.创建Callable 接口的实现类，并实现 call方法，该call方法将作为线程执行体，且该 call方法有返回值，再创建 Callable 实现类的实例。从Java 8开始，可以直接使用Lambda表达式创建Callable 对象。</p>
<p> 2.使用FutureTask类来包装Callable 对象，该 FutureTask 对象封装了该Callable 对象的 call（方法的返回值。 </p>
<p>3.使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</p>
<p>4.调用 FutureTask 对象的 get方法来获得子线程执行结束后的返回值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建FutureTask对象，callable对象使用lambda表达式</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;) ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lbh666&quot;</span>+<span class="string">&quot; curnum:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(task,<span class="string">&quot;lbh6666666&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<ul>
<li><h3 id="三种方法区别"><a href="#三种方法区别" class="headerlink" title="三种方法区别"></a>三种方法区别</h3></li>
</ul>
<blockquote>
<p>通过继承Thread 类或实现 Runnable、Callable 接口都可以实现多线程，不过实现 Runnable 接口与实现Callable 接口的方式基本相同，只是Callable 接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现 Runnable 接口和实现Callable 接口归为一种方式。这种方式与继承 Thread 方式之间的主要差别如下。</p>
<p> ##### 采用实现Runnable、Callable 接口的方式创建多线程的优缺点∶ </p>
<blockquote>
<p>优势：线程类只是实现了Runnable 接口或Callable 接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一 份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 </p>
<p>劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread方法</p>
</blockquote>
<h5 id="采用继承-Thread类的方式创建多线程的优缺点∶"><a href="#采用继承-Thread类的方式创建多线程的优缺点∶" class="headerlink" title="采用继承 Thread类的方式创建多线程的优缺点∶ "></a>采用继承 Thread类的方式创建多线程的优缺点∶ </h5><blockquote>
<p> 劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。 </p>
<p> 优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread方法，直接使用 this即可获得当前线程。 </p>
</blockquote>
</blockquote>
<p><strong>鉴于上面分析，因此一般推荐采用实现 Runnable 接口、Callable 接口的方式来创建多线程。</strong></p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img lazyload src="/images/loading.svg" data-src="E:\待更新博客\新建文件夹\JAVA多线程预习\image-20220209155349216.png" alt="image-20220209155349216"></p>
<h3 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h3><p>线程结束后就处于死亡状态，有三种结束方式</p>
<ul>
<li>run()或者call()方法执行完毕，线程正常结束</li>
<li>线程抛出一个未捕获的异常或error</li>
<li>使用线程的stop()方法结束线程(容易导致死锁，不推荐)</li>
</ul>
<p><strong>已经死亡的线程不能再start</strong></p>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><h4 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h4><ul>
<li><h5 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h5></li>
</ul>
<p>某个程序执行流调用其他线程的join()方法后，调用线程将会被阻塞，直到被join()方法加入的join()线程执行完毕</p>
<p>通常在主程序中将大问题分割为小问题，每个小问题用join()执行完毕，主线程再继续执行下去</p>
<ul>
<li><h5 id="后台线程-SetDaemon"><a href="#后台线程-SetDaemon" class="headerlink" title="后台线程 SetDaemon"></a>后台线程 SetDaemon</h5></li>
<li><h5 id="线程睡眠-Thread-sleep"><a href="#线程睡眠-Thread-sleep" class="headerlink" title="线程睡眠 Thread.sleep"></a>线程睡眠 Thread.sleep</h5></li>
</ul>
<p>当前线程变为阻塞，过了阻塞时间才会转入就绪状态，不关心其他线程的优先级</p>
<ul>
<li><h5 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步 yield"></a>线程让步 yield</h5></li>
</ul>
<p>当前线程变为<strong>就绪</strong>而不是阻塞，只给优先级相同或较高的线程执行机会</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p><code>a.SetPriority()</code>改变a线程的优先级，优先级高的线程执行机会更大，线程的默认优先级与创建它的父线程优先级相同</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//obj是同步监视器，线程开始执行同步代码块时必须先获得同步监视器的锁定</span></span><br></pre></td></tr></table></figure></div>
<p>任何线程在进入同步代码块时，首先对obj加锁，在加锁期间其他线程无法获得锁，无法进入同步代码块，当该线程执行完该同步代码块后，释放锁。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li>synchronized关键字修饰的方法，同步监视器是this(对象)，保证了任意时刻只有一个线程能获得该对象的锁</li>
<li>synchronized关键字不能修饰构造器、成员变量等</li>
<li>线程安全会降低程序运行效率，只对会改变竞争资源的方法进行同步</li>
</ul>
<h3 id="同步锁（Lock）"><a href="#同步锁（Lock）" class="headerlink" title="同步锁（Lock）"></a>同步锁（Lock）</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要保证线程安全的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> lbh&#123;</span><br><span class="line">        lock.lock();<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ...<span class="comment">//保证线程安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><strong>定义</strong>：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li><strong>例子</strong>：进程A锁住了记录1并等待记录2，而进程B锁住了记录2并等待记录1，这样两个进程就发生了死锁现象</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h3 id="1-传统线程通信"><a href="#1-传统线程通信" class="headerlink" title="1.传统线程通信"></a>1.传统线程通信</h3><ul>
<li><h4 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h4></li>
</ul>
<ol>
<li>wait()∶导致当前线程等待，<strong>释放当前线程的锁</strong>，直到其他线程调用该同步监视器的 notify()方法或 notifyAll()方法来唤醒该线程</li>
<li>notify()∶唤醒在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会选择唤醒其中一个线程。选择是任意性的。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li>
<li>notifyAll()∶ 唤醒在此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li>
</ol>
<ul>
<li><h4 id="调用手段（同步监视器对象调用）"><a href="#调用手段（同步监视器对象调用）" class="headerlink" title="调用手段（同步监视器对象调用）"></a>调用手段（同步监视器对象调用）</h4></li>
</ul>
<ol>
<li>对于synchronized修饰的同步方法，可以在方法中直接调用(this就是同步监视器)</li>
<li>对于synchronized修饰的同步代码块，用同步监视器对象即synchronized括号后的对象调用</li>
</ol>
<h3 id="2-Condition控制线程通信"><a href="#2-Condition控制线程通信" class="headerlink" title="2.Condition控制线程通信"></a>2.Condition控制线程通信</h3><ul>
<li><h5 id="使用情况：使用Lock来保证同步时"><a href="#使用情况：使用Lock来保证同步时" class="headerlink" title="使用情况：使用Lock来保证同步时"></a>使用情况：<strong>使用Lock来保证同步时</strong></h5></li>
<li><h5 id="三种方法-1"><a href="#三种方法-1" class="headerlink" title="三种方法"></a>三种方法</h5></li>
</ul>
<ol>
<li>await()</li>
<li>signal()</li>
<li>signalAll()</li>
</ol>
<ul>
<li><h5 id="类似于Lock对象充当同步监视器，Condition对象来暂停、唤醒线程"><a href="#类似于Lock对象充当同步监视器，Condition对象来暂停、唤醒线程" class="headerlink" title="类似于Lock对象充当同步监视器，Condition对象来暂停、唤醒线程"></a>类似于Lock对象充当同步监视器，Condition对象来暂停、唤醒线程</h5></li>
<li><p>举例</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition cond = <span class="keyword">new</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//需要保证线程安全的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> lbh&#123;</span><br><span class="line">        lock.lock();<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cond.await()</span><br><span class="line">            ...<span class="comment">//保证线程安全的代码</span></span><br><span class="line">            cond.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-BlockingQueue阻塞队列控制线程通信"><a href="#3-BlockingQueue阻塞队列控制线程通信" class="headerlink" title="3.BlockingQueue阻塞队列控制线程通信"></a>3.BlockingQueue阻塞队列控制线程通信</h3><ul>
<li><strong>方法</strong></li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="E:\待更新博客\新建文件夹\JAVA多线程预习\image-20220210061627598.png" alt="image-20220210061627598"></p>
<ul>
<li><strong>实现类</strong></li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="E:\待更新博客\新建文件夹\JAVA多线程预习\image-20220210061939323.png" alt="image-20220210061939323"></p>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><ul>
<li>线程在创建时可以指定线程组<code>Thread(ThreadGroup group, Runnable target, String name)</code>，没有指定线程组则属于默认线程组，线程的线程组一旦确定不可更改</li>
<li>线程组可对一组的线程进行操作</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>复用一组线程把，很多小任务让一组线程来执行，而不是一个任务对应一个新线程，这种能接收大量小任务并进行分发处理的就是线程池</p>
<p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理</p>
<p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure></div>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><strong>每个线程都有自己独立的调用栈，局部变量保存在线程各自的调用栈里，不会共享，不存在并发安全问题</strong></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p>
<p><strong>JVM规范定义了几种原子操作</strong>：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。（但是，如果是多行赋值语句，就必须保证是同步操作）</li>
</ul>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p><strong>volatile关键字的两层语义</strong></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>1.保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2.禁止进行指令重排序。</p>
<p>3.volatile不保证原子性(i++会有问题)</p>
<p>4.volatile解决可见性问题，不解决原子性问题</p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>适用于<strong>允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待</strong>的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">读</th>
<th style="text-align:left">写</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">读</td>
<td style="text-align:left">允许</td>
<td>不允许</td>
</tr>
<tr>
<td style="text-align:left">写</td>
<td style="text-align:left">不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
</div>
<p>使用<code>ReadWriteLock</code>可以提高读取效率：</p>
<ul>
<li><code>ReadWriteLock</code>只允许一个线程写入；</li>
<li><code>ReadWriteLock</code>允许多个线程在没有写入时同时读取；</li>
<li><code>ReadWriteLock</code>适合读多写少的场景</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2022/02/26/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1>泛型</h1>
<ul>
<li>如果Foo是 Bar的一个子类型（子类或者子接口），而 G是具有泛型声明的类或接口，G&lt;Foo&gt;并不是G&lt;Bar&gt;的子类型</li>
<li>数组和泛型有所不同，假设Foo是Bar 的一个子类型（子类或者子接口），那么Foo[]依然是 Bar[]的子类型;但 G&lt;Foo&gt;不是 G&lt;Bar&gt;的子类型。</li>
</ul>
<span id="more"></span>
<h2 id="深入泛型">深入泛型</h2>
<h3 id="创建泛型">创建泛型</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类时定义了一个形参T</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//在类里T可以作为参数类型使用</span></span><br><span class="line">    T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参，从而可以动态地生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</li>
</ul>
<h3 id="泛型类派生子类">泛型类派生子类</h3>
<p>当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或从该父类派生子类，需要指出的是，当使用这些接口、父类时不能再包含类型形参</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt; //错误</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span>&lt;<span class="title">String</span>&gt; //正确</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> //警告，会把<span class="title">T</span>默认当初<span class="title">Object</span>类</span></span><br></pre></td></tr></table></figure></div>
<h2 id="类型通配符">类型通配符</h2>
<h3 id="简介">简介</h3>
<p>类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List&lt;String&gt;、List&lt;Integer&gt;</p>
<p>等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        </span><br><span class="line">        name.add(<span class="string">&quot;icon&quot;</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;data :&quot;</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="类型通配符上限">类型通配符上限</h3>
<p><code>List&lt;? extends A&gt;</code>表示只能传入A及A的子类，同时，因为无法确定List中的类型是什么，所以List&lt;?&gt;无法添加任何元素（除了null）</p>
<h3 id="类型通配符下限">类型通配符下限</h3>
<p>下限：&lt;? super T&gt; ?是T和T的父类</p>
<ul>
<li>
<p>Treeset构造器有形参<code>Treeset(Comparator&lt;? super E&gt;)</code>，表示可以按照Treeset类型参数及其父类来进行排序</p>
</li>
<li>
<? super T> 可以添加T或者T的子类，但取出的一定是object类
</li>
</ul>
<h3 id="设定类型形参上限">设定类型形参上限</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义类时定义了一个形参T</span><br><span class="line">//使用A类时为T形参传入的实际参数只能是Number或Number的子类</span><br><span class="line">public class A&lt;T extends Number&gt; &#123;</span><br><span class="line">    //在类里T可以作为参数类型使用</span><br><span class="line">    T a;</span><br><span class="line">    public T add(T a, T b) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="泛型方法">泛型方法</h3>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CJava%E6%B3%9B%E5%9E%8B%5C09221852-b0d764f4340946baa1a063da5a0d993e.png" alt="09221852-b0d764f4340946baa1a063da5a0d993e"></p>
<p>泛型方法也可以设定上限</p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CJava%E6%B3%9B%E5%9E%8B%5Cimage-20220226202701317.png" alt="image-20220226202701317"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式学习</title>
    <url>/2022/02/18/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="正则表达式基础">正则表达式基础</h2>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216145536306.png" alt="image-20220216145536306"></p>
<span id="more"></span>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216145548834.png" alt="image-20220216145548834"></p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216145610336.png" alt="image-20220216145610336"></p>
<blockquote>
<p><strong>注意：java中正则表达式里&quot;\“本身需要转义，因此要匹配”?“需要表达式”\\?“而不是”\?&quot;</strong></p>
<p>在其他语言中，<strong>\</strong> 表示：<strong>我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</strong></p>
<p>在 Java 中，<strong>\</strong> 表示：<strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216145915431.png" alt="image-20220216145915431"></p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216150018227.png" alt="image-20220216150018227"></p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216150637142.png" alt="image-20220216150637142"></p>
<h3 id="捕获组">捕获组</h3>
<h4 id="简介-2">简介</h4>
<ul>
<li>
<p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建</p>
</li>
<li>
<p>例如，正则表达式 (dog) 创建了单一分组，组里包含&quot;d&quot;，“o”，和&quot;g&quot;。</p>
</li>
<li>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B©))</li>
</ul>
<ul>
<li>
<p>(A)</p>
</li>
<li>
<p>(B©)</p>
</li>
<li>
<p>©</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>((A)|(B)|©)匹配A,B,C其中一个</li>
</ul>
<h4 id="命名捕获组">命名捕获组</h4>
<ul>
<li>格式</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(?&lt;name&gt;.....)</span><br></pre></td></tr></table></figure></div>
<p>若Matcher对象匹配成功，使用Matcher对象的group(“name”)方法即可返回该捕获组内容</p>
<ul>
<li>例子</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String dataRe = <span class="string">&quot;(?&lt;date&gt;(?&lt;year&gt;\\d&#123;1,4&#125;)/(?&lt;month&gt;\\d&#123;1,2&#125;)/(?&lt;day&gt;\\d&#123;1,2&#125;))&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(dataRe);</span><br><span class="line">Matcher m = p.matcher(<span class="string">&quot;2022/2/18&quot;</span>);</span><br><span class="line">m.find();</span><br><span class="line">System.out.println(m.group(<span class="string">&quot;year&quot;</span>)); <span class="comment">//输出2022</span></span><br></pre></td></tr></table></figure></div>
<h3 id="数量匹配符匹配模式">数量匹配符匹配模式</h3>
<ul>
<li>贪婪模式(Greedy):遇到满足的一直匹配，直到无法匹配</li>
<li>勉强模式(Reluctant):以?结尾，匹配最少字符</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216152228868.png" alt="image-20220216152228868"></p>
<h2 id="String类里的正则表达式方法">String类里的正则表达式方法</h2>
<blockquote>
<p><img lazyload src="/images/loading.svg" data-src="E:%5CBlog%5Csource_posts%5CJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%5Cimage-20220216144425795.png" alt="image-20220216144425795"></p>
</blockquote>
<h2 id="regex库">regex库</h2>
<p>Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为Pattern 对象，然后再利用该Pattern 对象创建对应的 Matcher 对象。执行匹配所涉及的状态保留在 Matcher 对象中，多个 Matcher 对象可共享同一个Pattern 对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模式串</span></span><br><span class="line">String pattern = <span class="string">&quot;waitToCompile&quot;</span></span><br><span class="line"><span class="comment">//待匹配对象</span></span><br><span class="line">String line = <span class="string">&quot;WaitToMatch&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">Pattern r = Pattern.compile(pattern);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">Matcher m = r.matcher(line);</span><br></pre></td></tr></table></figure></div>
<h3 id="Matcher常用方法">Matcher常用方法</h3>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>end()</code>返回最后一个字符匹配后的偏移量。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>end(int group)</code>返回在上次匹配操作期间由给定组捕获的子序列的最后一个字符之后的偏移量。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>end(String name)</code>返回给定捕获子序列的最后一个字符之后的偏移量 <a class="link" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#groupname">named-capturing group <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以前的匹配操作期间。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>find()</code>尝试找到匹配模式的输入序列的下一个子序列。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>find(int start)</code>重新设置该匹配器，然后尝试从指定的索引开始找到匹配模式的输入序列的下一个子序列。</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>group()</code>返回与上一个匹配匹配的输入子序列。</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>group(int group)</code>返回在上一次匹配操作期间由给定组捕获的输入子序列。</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>group(String name)</code>返回给定捕获的输入子序列 <a class="link" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#groupname">named-capturing group <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以前的匹配操作期间。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>groupCount()</code>返回此匹配器模式中捕获组的数量。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hitEnd()</code>如果在匹配器执行的最后一次匹配操作中输入的结尾被搜索引擎命中，则返回true。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>lookingAt()</code>尝试将输入序列从区域开头开始与模式相匹配。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>matches()</code>尝试将整个区域与模式进行匹配。</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java预习</title>
    <url>/2022/02/08/Java%E9%A2%84%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、零碎知识点">一、零碎知识点</h2>
<ul>
<li>
<h5 id="Java中字符串-判断两个字符串地址是否相等，-equals-判断字符串是否相等">Java中字符串&quot;==&quot;判断两个字符串地址是否相等，.equals()判断字符串是否相等</h5>
</li>
</ul>
<ul>
<li>
<h5 id="final关键字只是表示对象引用不会再指向另一个不同的对象，但当前的对象可以更改">final关键字只是表示对象引用不会再指向另一个不同的对象，但当前的对象可以更改</h5>
</li>
<li>
<h5 id="静态方法是不在对象上执行的方法">静态方法是不在对象上执行的方法</h5>
</li>
<li>
<h5 id="数组作为参数是引用传递-可以在方法中修改传递过来的数组">数组作为参数是引用传递,可以在方法中修改传递过来的数组</h5>
</li>
<li>
<h5 id="main-方法是被-JVM-调用的">main 方法是被 JVM 调用的</h5>
</li>
</ul>
<span id="more"></span>
<ul>
<li>
<h5 id="方法重载-一个类的两个方法拥有相同的名字，但是有不同的参数列表-重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。">方法重载:一个类的两个方法拥有相同的名字，但是有不同的参数列表(重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。)</h5>
</li>
<li>
<h5 id="不管你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0">不管你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0</h5>
</li>
<li>
<h5 id="JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本，s1-“ab”-s2-“a”-“b”-s2直接引用常量池中的-ab-，s1与s2指向同一个对象">JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本，s1 = “ab”, s2 = “a” + “b”,s2直接引用常量池中的&quot;ab&quot;，s1与s2指向同一个对象</h5>
</li>
<li>
<p>Objects类的克隆是浅克隆，对象实例变量只复制了引用</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200914213258544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loOTkxMzE0,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="二、方法修饰符">二、方法修饰符</h2>
<ol>
<li>public（公共控制符），包外包内都可以调用该方法。</li>
<li>protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。具体细节可参考：<a class="link" href="http://blog.csdn.net/dawn_after_dark/article/details/74453915">http://blog.csdn.net/dawn_after_dark/article/details/74453915 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>default（默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。</li>
<li>private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。</li>
<li>final，指定方法已完备，不能再进行继承扩充。</li>
<li>static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。</li>
<li>synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。</li>
<li>native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。</li>
<li>abstract，抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：<code>public abstract sample();</code> 。</li>
</ol>
<h2 id="三、变量修饰符">三、变量修饰符</h2>
<h3 id="1、成员变量修饰符">1、成员变量修饰符</h3>
<ol>
<li>public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。</li>
<li>protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。</li>
<li>default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。</li>
<li>private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。</li>
<li>final，最终修饰符，指定此变量的值不能变。</li>
<li>static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。</li>
<li>transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。</li>
<li>volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。</li>
</ol>
<blockquote>
<p>final 和 static 经常一起使用来创建常量。</p>
</blockquote>
<h3 id="2、局部变量修饰符">2、局部变量修饰符</h3>
<p>只能使用 final 修饰局部变量<br>
（1）为什么不能赋予权限修饰符？<br>
因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。<br>
（2）为什么不能用static修饰<br>
我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？</p>
<h5 id="java一个包可以有无数个public类，但一个文件只能有一个public类">java一个包可以有无数个public类，但一个文件只能有一个public类</h5>
<h5 id="继承链中对象方法的调用的优先级：this-show-O-、super-show-O-、this-show-super-O-、super-show-super-O-。（父类引用指向子类对象）">继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。（父类引用指向子类对象）</h5>
<h2 id="五、多态">五、多态</h2>
<ul>
<li>编译时结果和运行时结果不一样（父类引用指向子类对象，只能使用父类中的方法(被子类重写的调用子类)）</li>
<li>向上转型与向下转型</li>
</ul>
<h2 id="六、java中遍历集合的三种方式">六、java中遍历集合的三种方式</h2>
<p>集合遍历操作的三种方式</p>
<ol>
<li>Iterator迭代器方式</li>
<li>增强for循环</li>
<li>普通for循环</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> String(<span class="string">&quot;JavaEE&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Date());</span><br><span class="line">        list.add(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="comment">//1.Iterator迭代器方式</span></span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.普通for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="七、内部类">七、内部类</h2>
<ul>
<li>与内部类相对的外部类只有public和默认访问权限，前者可以被任何位置访问，后者只能被同一个包内的其他类访问。而内部类因为在外部类中，所以有public private protected等修饰</li>
</ul>
<h3 id="1-非静态内部类">1.非静态内部类</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="comment">//非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化内部类</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">A.B b = a.<span class="function">new <span class="title">B</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>内部类编译后的格式是Outerclass$InnerClass.class</p>
</li>
<li>
<p>非静态内部类可以访问外部类的private成员(<strong>内部类对象中有隐式引用指向外部类对象</strong>)，但外部类不能直接访问内部类的任何成员，只能通过创建内部类对象来访问其实例成员</p>
</li>
<li>
<p>在非静态内部类中，外部类成员变量与非静态内部类成员变量和局部变量重名时(如都为lbh)，访问局部变量直接使用lbh，非静态内部类成员变量使用this.lbh，外部类使用A.this.lbh(A为外部类名称)</p>
</li>
<li>
<p>根据<strong>静态成员不能访问非静态成员</strong>的规则，外部类的静态成员(静态初始化块、静态方法)不能直接使用非静态内部类。同时非静态内部类里不能定义静态方法、成员等</p>
</li>
<li>
<p>非静态内部类的子类可以是外部类，但也有对外部类对象的隐式引用</p>
</li>
</ul>
<h3 id="2-静态内部类">2.静态内部类</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>静态内部类可以包含静态和非静态的成员，根据<strong>静态成员不能访问非静态成员</strong>的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。外部类不能直接访问静态内部类的成员，但可以通过B.name访问静态内部类的类成员，通过静态内部类的对象访问实例成员</li>
</ul>
<h3 id="3-内部类使用">3.内部类使用</h3>
<ul>
<li>
<h4 id="在外部类内部使用">在外部类内部使用</h4>
</li>
</ul>
<p>​		和普通实例化一样</p>
<ul>
<li>
<h4 id="在外部类外部使用">在外部类外部使用</h4>
</li>
</ul>
<h5 id="（1）非静态内部类">（1）非静态内部类</h5>
<p><strong><code> OuterClass.InnerClass varname = new OuterClass.new InnerClass();</code></strong> 非静态内部类的构造器必须由外部类来调用</p>
<h5 id="（2）静态内部类">（2）静态内部类</h5>
<p><code>OuterClass.InnerClass varname = new OuterClass.InnerClass();</code></p>
<h3 id="4-局部内部类">4.局部内部类</h3>
<ul>
<li>方法中定义，与普通类使用一样</li>
</ul>
<h3 id="5-匿名内部类">5.匿名内部类</h3>
<ul>
<li>
<p>使用局部内部类时，只想<strong>创建这个类的一个对象</strong>时使用匿名内部类</p>
</li>
<li>
<p>从上面定义可以看出，<strong>匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口</strong>。 关于匿名内部类还有如下两条规则。1、匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因 此不允许将匿名内部类定义成抽象类。2、 匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类 可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</p>
</li>
<li>
<h5 id="匿名内部类语法">匿名内部类语法</h5>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">//可以实现接口(<span class="title">Comparator</span>)和扩展超类</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<h5 id="双括号初始化">双括号初始化</h5>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="number">1</span>);</span><br><span class="line">        add(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        put(<span class="string">&quot;a&quot;</span>,<span class="number">114514</span>);</span><br><span class="line">        put(<span class="string">&quot;lbh&quot;</span>,<span class="number">66666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>注意</strong>：（以map为例）双括号初始化其实是利用匿名内部类实例化了一个HashMap的子类，子类中有初始化块，并向上转型为HashMap，引用传给map</p>
<h2 id="八、类与对象">八、类与对象</h2>
<ul>
<li>
<p>如果需要在子类方法中调用父类被覆盖的实例方法，则可使用 super 限定来调用父类被覆盖的实例方法。</p>
</li>
<li>
<p><strong>构造器不能用void声明</strong>，因为这是Java语法规定。实际上构造器返回的是类的对象。</p>
</li>
</ul>
<h3 id="构造器">构造器</h3>
<ul>
<li>如果程序员没有为 Java 类提供任何构造器，则系统会为这个类提供一个无参数的构造器，这个构造器的执行体为空，不做任何事情。无论如何，Java类至少包含一个构造器。</li>
<li>当构造器B完全包含构造器A时，可以在构造器B中使用this(a,b,c)调用A构造器简化程序</li>
</ul>
<h4 id="子类调用父类构造器">子类调用父类构造器</h4>
<p>不管是否使用super 调用来执行父类构造器的初始化代码，子类构造器总会调用父类构造器一次。子类构造器调用父类构造器分如下几种情况。</p>
<p>* 子类构造器执行体的第一行使用 super 显式调用父类构造器，系统将根据 super调用里传入的实 参列表调用父类对应的构造器。</p>
<ul>
<li>
<p>子类构造器执行体的第一行代码使用 this 显式调用本类中重载的构造器，系统将根据 this 调用里 传入的实参列表调用本类中的另一个构造器。执行本类中另一个构造器时即会调用父类构造器。&gt;</p>
</li>
<li>
<p>子类构造器执行体中既没有 super 调用，也没有 this 调用，系统将会在执行子类构造器之前，隐 式调用父类无参数的构造器。</p>
</li>
</ul>
<p>不管上面哪种情况，当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行∶不仅如此，执行父类构造器时，系统会再次上溯执行其父类构造器…·依此类推，创建任何 Java 对象，最先执行的总是 java.lang.Obiect 类的构造器。</p>
<h3 id="方法重写">方法重写</h3>
<p>方法的重写要遵循&quot;两同两小一大&quot;规则</p>
<p>&quot;两同&quot;即方法名相同、形参列表相同;</p>
<p>&quot;两小&quot;指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;</p>
<p>&quot;一大&quot;指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
<p>尤其需要指出的是，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法</p>
<h3 id="单例类-Singleton">单例类(Singleton)</h3>
<p>只能创建一个对象</p>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CJava%E9%A2%84%E4%B9%A0%5C3.png" alt="3"></p>
<h3 id="final类">final类</h3>
<p>final修饰的类不能有子类</p>
<h3 id="不可变类">不可变类</h3>
<p>不可变（immutable）类的意思是创建该类的实例后，该实例的实例变量是不可改变的。Java 提供的8个包装类和 java.lang.String类都是不可变类，当创建它们的实例后，其实例的实例变量不可改变。</p>
<h2 id="九、接口">九、接口</h2>
<ul>
<li>接口不是类，而是对希望符合这个接口的类的一组需求</li>
<li>接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类</li>
<li>接口中的方法都为public</li>
<li>接口里的成员变量只能且默认是public static final修饰</li>
<li>默认方法—为接口方法提供一个默认实现，如<code> defalut int compareTo(T other)&#123;return 0;&#125;</code></li>
<li>一个类实现的接口和继承的类中方法冲突时，只考虑超类方法；接口方法冲突时必须覆盖这个方法</li>
<li>从某个角度来看，接口可被当成一个特殊的类，因此一个 Java 源文件里最多只能有一个 public 接口，如果一个Java 源文件里定义了一个public 接口，则该源文件的主文件名必须与该接口名相同。</li>
</ul>
<h2 id="十、lambda表达式">十、lambda表达式</h2>
<h3 id="1-语法">1.语法</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(Type o1, Type o2)-&gt;&#123;.......&#125;</span><br><span class="line">()-&gt;&#123;.......&#125;</span><br><span class="line">(Type o)-&gt;&#123;......&#125;</span><br><span class="line"><span class="comment">//如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</span></span><br><span class="line">(o)-&gt;&#123;......&#125;</span><br><span class="line">(o1,o2)-&gt;&#123;.........&#125;</span><br><span class="line"><span class="comment">//只有一行可以省略&#123;&#125;</span></span><br><span class="line">(o1,o2)-&gt;o1[<span class="number">1</span>]-o2[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>
<h3 id="2、函数式接口">2、函数式接口</h3>
<h2 id="2"><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CJava%E9%A2%84%E4%B9%A0%5C2.png" alt="2"></h2>
<h4 id="函数式接口举例">函数式接口举例</h4>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CJava%E9%A2%84%E4%B9%A0%5C1.png" alt="1"></p>
<p><strong>lambda表达式的目标类型必须是函数式接口（Object也不行），但同样的 Lambda 表达式的目标类型完全可能是变化的——唯一的要求是，Lambda 表达式实现的匿名方法与目标类型（函数式接口）中唯一的抽象方法有相同的形参列表。 </strong></p>
<h3 id="3、方法引用">3、方法引用</h3>
<table>
<thead>
<tr>
<th>情况</th>
<th>解释</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>object::instanceMethod</td>
<td>等价于向方法传递参数的lambda表达式</td>
<td>System.out::println等价于x-&gt;System.out.println(x)</td>
</tr>
<tr>
<td>Class::instanceMethod</td>
<td>第一个参数成为方法的隐式参数</td>
<td>String::compareTo等价于x.compareTo(y)</td>
</tr>
<tr>
<td>Class::staticMethon</td>
<td>所有参数都传递到静态方法中</td>
<td>Math::pow等价于Math.pow(x,y)</td>
</tr>
</tbody>
</table>
<h3 id="4-构造器引用">4.构造器引用</h3>
<ul>
<li>int[]::new等价于x-&gt;new iny[x]</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA</title>
    <url>/2023/01/23/LCA/</url>
    <content><![CDATA[<h1>LCA</h1>
<h2 id="朴素作法">朴素作法</h2>
<p>对于每次询问，分别从两点出发，遍历所有祖先节点找到相同的节点</p>
<span id="more"></span>
<h2 id="树上倍增">树上倍增</h2>
<p>利用倍增思想，一次可以走2<sup>k</sup></p>
<p>首先预处理depth[N]数组，表示每个点的深度，预处理fa[N][M]数组，fa[a][i]表示a点向上走2<sup>i</sup>步后到达的节点(bfs)</p>
<p>假设查询的点为x,y，且x深度大于y</p>
<p>预处理数组</p>
<p>1.从x出发，利用fa[x][i]数组，找到与y同一层的x的祖宗节点z，若此时z==y，则已经找到，最近公共祖先为y</p>
<p>2.否则从z和y出发，利用f[N][M]寻找z和y的最近公共祖先(M从log(max(depth))遍历到0)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40007</span>, M = <span class="number">2</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">17</span>], depth[N], q[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">	depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	depth[root] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = root;</span><br><span class="line">	<span class="keyword">while</span>(hh &lt;= tt) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q[hh++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> b = e[i];</span><br><span class="line">			<span class="keyword">if</span> (depth[b] &gt; depth[x] + <span class="number">1</span>) &#123;</span><br><span class="line">				depth[b] = depth[x] + <span class="number">1</span>;</span><br><span class="line">				fa[b][<span class="number">0</span>] = x;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">					fa[b][i] = fa[fa[b][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				q[++tt] = b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depth[a] &lt; depth[b]) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (depth[fa[a][i]] &gt;= depth[b]) &#123;</span><br><span class="line">			a = fa[a][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[a][i] != fa[b][i]) &#123;</span><br><span class="line">			a = fa[a][i];</span><br><span class="line">			b = fa[b][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> root;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">-1</span>) &#123;</span><br><span class="line">			root = a;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">add</span>(a,b);</span><br><span class="line">			<span class="built_in">add</span>(b,a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">bfs</span>(root);</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="built_in">lca</span>(x, y);</span><br><span class="line">		<span class="keyword">if</span> (ans == x) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans == y) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="Tarjan">Tarjan</h2>
<p>将树中的点分成三类，一类是已经搜索并且回溯过的(2)，一类是正在搜索中的(1)，一类是未搜索的(0)，在dfs搜索某个点时将该点标记为1，对该点的子节点使用tarjan，然后利用并查集维护子节点的父节点为该节点。</p>
<p>对子节点应用完tarjan后将遍历所有对该点的询问，若询问的另一点st为2，则已经搜索并回溯过，利用并查集find到祖宗节点，该节点便是该点与另一点的最近公共祖先</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2022/03/05/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="使用">使用</h2>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div>
<h2 id="makefile的规则">makefile的规则</h2>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<span id="more"></span>
<ul>
<li>例子</li>
</ul>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>command前以tab开头</p>
</li>
<li>
<p>target</p>
<ul>
<li>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。</li>
</ul>
</li>
<li>
<p>prerequisites</p>
<ul>
<li>生成该target所依赖的文件和/或target</li>
</ul>
</li>
<li>
<p>command</p>
<ul>
<li>该target要执行的命令（任意的shell命令）</li>
</ul>
</li>
</ul>
<blockquote>
<p>target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中</p>
<p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p>
</blockquote>
<ul>
<li>利用&quot;\&quot;换行</li>
</ul>
<h3 id="变量">变量</h3>
<h5 id="定义">定义</h5>
<p>1.“=”(前面定义的变量可以使用后面定义的变量，不推荐)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo = $(bar)</span><br><span class="line">bar = $(ugh)</span><br><span class="line">ugh = Huh?</span><br></pre></td></tr></table></figure></div>
<p>2.“:=&quot;(前面定义的变量无法使用后面定义的变量，推荐)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure></div>
<p>3.“?=”(其含义是，如果左边变量没有被定义过，那么变量的值就是右值，如果左边变量先前被定义过，那么这条语句将什么也不做)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure></div>
<h5 id="追加变量值">追加变量值</h5>
<p>可以使用 <code>+=</code> 操作符给变量追加值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects := main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line">##$(objects) 值变成：“main.o foo.o bar.o utils.o another.o”</span><br></pre></td></tr></table></figure></div>
<h5 id="例子">例子</h5>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<p>1.Makefile中的变量其实就是C/C++中的宏</p>
<p>2.变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果要使用真实的 <code>$</code> 字符，那么需要用 <code>$$</code> 来表示。</p>
<h3 id="清空目标文件的规则">清空目标文件的规则</h3>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<p><code>.PHONY</code> 表示 <code>clean</code> 是一个“伪目标”。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事</p>
<h2 id="书写规则">书写规则</h2>
<p>Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的,第一条规则中的目标将被确立为最终的目标，如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标</p>
<h2 id="伪目标">伪目标</h2>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure></div>
<p><strong>当遇到目标体clean时,make先查看其是否有依赖体(prerequisites),因为clean没有依赖体,所以make认为目标体是最新的而不执行任何操作.为了编译这个目标体,必须输入make clean.</strong></p>
<h2 id="命令执行">命令执行</h2>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令</p>
<blockquote>
<p>因为每行命令在一个单独的shell中执行。这些Shell之间没有继承关系，两行命令在两个不同的进程执行</p>
</blockquote>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>或者加上&quot;\&quot;</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="通配符使用">通配符使用</h2>
<p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code></p>
<ul>
<li>”/“是根目录，”~“是家目录。Linux存储是以挂载的方式，相当于是树状的，源头就是”/“，也就是根目录。而每个用户都有”家“目录，也就是用户的个人目录，比如root用户的”家“目录就是/root,普通用户a的家目录就是/home/a
<ul>
<li><code>~hchen/test</code> 则表示用户hchen的宿主目录下的test 目录</li>
</ul>
</li>
<li>* 匹配任意长度的任意字符，可以是0个
<ul>
<li><code>*.c</code> 表示所有后缀为c的文件</li>
</ul>
</li>
<li>? 匹配任意单个字符，必须是1个</li>
</ul>
<h4 id="变量中通配符展开">变量中通配符展开</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects := $(wildcard *.o) #objects的值是所有 .o 的文件名的集合</span><br><span class="line">objects = *.o #object只是*.o</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux预习</title>
    <url>/2022/02/18/Linux%E9%A2%84%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="零碎知识点">零碎知识点</h2>
<ul>
<li>“Shell”——也可称为&quot;壳&quot;，充当的是人与内核（硬件）的翻译官，用户将一些命令&quot;告诉&quot;Shell，它就会调用相应的程序服务执行工作</li>
<li>若一个命令太长一行放不下，可在行尾输入&quot;\&quot;并按回车，可转到下一行输入</li>
<li>.开头的隐藏文件，用 ls -a才能查看</li>
<li>定义别名、shell变量赋值时“=”两端不能有空格</li>
</ul>
<span id="more"></span>
<h2 id="Linux常用命令">Linux常用命令</h2>
<h3 id="概述">概述</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">who <span class="comment">#命令列出所有正在使用系统的用户、所用终端名和注册到系统的时间</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">date </span><br><span class="line"></span><br><span class="line">cal [月份] [年份] <span class="comment">#显示日历，默认本月日历</span></span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">passwd <span class="comment">#改密码</span></span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">cat -bns file</span><br><span class="line"><span class="comment">#cat m1 显示m1内容</span></span><br><span class="line"><span class="comment">#cat m1 m2 显示m1 m2内容</span></span><br><span class="line"><span class="comment">#cat m1 m2 &gt; m3 将m1 m2内容合并后放入m3</span></span><br><span class="line"></span><br><span class="line">more -dcs -num file</span><br><span class="line"></span><br><span class="line">less</span><br><span class="line"></span><br><span class="line">head -num -cnqv file <span class="comment">#显示文件开头若干行，默认10</span></span><br><span class="line"></span><br><span class="line">tail -cfnqv file <span class="comment">#显示file末尾若干行，默认10</span></span><br><span class="line"></span><br><span class="line">touch -acmt file <span class="comment">#修改file时间标签为当前时间，文件不存在则创建</span></span><br><span class="line"></span><br><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--<span class="built_in">help</span>][范本样式][文件或目录...]</span><br><span class="line"><span class="comment">#grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</span></span><br><span class="line"></span><br><span class="line">sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--<span class="built_in">help</span>][--verison][文件][-k field1[,field2]]</span><br><span class="line"><span class="comment">#sort 可针对文本文件的内容，以行为单位来排序。</span></span><br><span class="line"></span><br><span class="line">uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--<span class="built_in">help</span>][--version][输入文件][输出文件]</span><br><span class="line"><span class="comment">#Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</span></span><br><span class="line"><span class="comment">#uniq 可检查文本文件中重复出现的行列。</span></span><br><span class="line"></span><br><span class="line">cp</span><br><span class="line"></span><br><span class="line">rm</span><br><span class="line"></span><br><span class="line">mv</span><br><span class="line"></span><br><span class="line">wc [-clw][--<span class="built_in">help</span>][--version][文件...]</span><br><span class="line"><span class="comment">#利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为&quot;-&quot;，则wc指令会从标准输入设备读取数据。</span></span><br><span class="line"><span class="comment">#$ wc testfile           # testfile文件的统计信息  </span></span><br><span class="line"><span class="comment">#3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#当前目录绝对路径名</span></span><br><span class="line"></span><br><span class="line">mkdir</span><br><span class="line"></span><br><span class="line">rmdir</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line">ls <span class="comment">#列出目录内容</span></span><br></pre></td></tr></table></figure></div>
<h4 id="详细可查阅"><a class="link" href="https://www.linuxcool.com/">详细可查阅 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4>
<h3 id="命令详细">命令详细</h3>
<h3 id="1-wc">1.wc</h3>
<p>wc命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。</p>
<p>**语法格式：**wc [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-w</th>
<th>统计字数，或–words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>统计字节数，或–bytes或–chars：只显示Bytes数</td>
</tr>
<tr>
<td>-l</td>
<td>统计行数，或–lines：只显示列数</td>
</tr>
<tr>
<td>-m</td>
<td>统计字符数</td>
</tr>
<tr>
<td>-L</td>
<td>打印最长行的长度</td>
</tr>
<tr>
<td>–help</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="2-rm">2.rm</h3>
<p>rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm也是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<p>**语法格式：**rm [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-f</th>
<th>忽略不存在的文件，不会出现警告信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>删除前会询问用户是否操作</td>
</tr>
<tr>
<td>-r/R</td>
<td>递归删除</td>
</tr>
<tr>
<td>-v</td>
<td>显示指令的详细执行过程</td>
</tr>
</tbody>
</table>
<h3 id="3-cp">3.cp</h3>
<p>cp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。</p>
<p>cp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p>
<p>**语法格式：**cp [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-f</th>
<th>若目标文件已存在，则会直接覆盖原文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>若目标文件已存在，则会询问是否覆盖</td>
</tr>
<tr>
<td>-p</td>
<td>保留源文件或目录的所有属性</td>
</tr>
<tr>
<td>-r</td>
<td>递归复制文件和目录</td>
</tr>
<tr>
<td>-d</td>
<td>当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录</td>
</tr>
<tr>
<td>-l</td>
<td>对源文件建立硬连接，而非复制文件</td>
</tr>
<tr>
<td>-s</td>
<td>对源文件建立符号连接，而非复制文件</td>
</tr>
<tr>
<td>-b</td>
<td>覆盖已存在的文件目标前将目标文件备份</td>
</tr>
<tr>
<td>-v</td>
<td>详细显示cp命令执行的操作过程</td>
</tr>
<tr>
<td>-a</td>
<td>等价于“dpr”选项</td>
</tr>
</tbody>
</table>
<h3 id="4-diff命令-–-比较文件的差异">4.diff命令 – 比较文件的差异</h3>
<p>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录 。</p>
<p>**语法格式：**diff [参数] [目录]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-a</th>
<th>diff预设只会逐行比较文本文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-b</td>
<td>不检查空格字符的不同</td>
</tr>
<tr>
<td>-W</td>
<td>在使用-y参数时，指定栏宽</td>
</tr>
<tr>
<td>-x</td>
<td>不比较选项中所指定的文件或目录</td>
</tr>
<tr>
<td>-X</td>
<td>您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件</td>
</tr>
<tr>
<td>-y</td>
<td>以并列的方式显示文件的异同之处</td>
</tr>
<tr>
<td>–help</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>–left-column</td>
<td>在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容</td>
</tr>
<tr>
<td>–suppress-common-lines</td>
<td>在使用-y参数时，仅显示不同之处</td>
</tr>
</tbody>
</table>
<h3 id="5-df命令-–-显示磁盘空间使用情况">5.df命令 – 显示磁盘空间使用情况</h3>
<p>df命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。</p>
<p>日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p>
<p><strong>语法格式：</strong> df [参数] [指定文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-a</th>
<th>显示所有系统文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-B &lt;块大小&gt;</td>
<td>指定显示时的块大小</td>
</tr>
<tr>
<td>-h</td>
<td>以容易阅读的方式显示</td>
</tr>
<tr>
<td>-H</td>
<td>以1000字节为换算单位来显示</td>
</tr>
<tr>
<td>-i</td>
<td>显示索引字节信息</td>
</tr>
<tr>
<td>-k</td>
<td>指定块大小为1KB</td>
</tr>
<tr>
<td>-l</td>
<td>只显示本地文件系统</td>
</tr>
<tr>
<td>-t &lt;文件系统类型&gt;</td>
<td>只显示指定类型的文件系统</td>
</tr>
<tr>
<td>-T</td>
<td>输出时显示文件系统类型</td>
</tr>
<tr>
<td>– -sync</td>
<td>在取得磁盘使用信息前，先执行sync命令</td>
</tr>
</tbody>
</table>
<h3 id="6-du命令-–-查看空间">6.du命令 – 查看空间</h3>
<p>du命令的英文全称是“Disk Usage”，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区。</p>
<p>**语法格式：**du [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-a</th>
<th>显示目录中所有文件大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>-k</td>
<td>以KB为单位显示文件大小</td>
</tr>
<tr>
<td>-m</td>
<td>以MB为单位显示文件大小</td>
</tr>
<tr>
<td>-g</td>
<td>以GB为单位显示文件大小</td>
</tr>
<tr>
<td>-h</td>
<td>以易读方式显示文件大小</td>
</tr>
<tr>
<td>-s</td>
<td>仅显示总计</td>
</tr>
</tbody>
</table>
<blockquote>
<p>du查看当前目录及递归查看子目录大小,  du -a在du基础上查看了文件大小</p>
</blockquote>
<h3 id="7-less命令-–-分页显示工具">7.less命令 – 分页显示工具</h3>
<p>浏览文字档案的内容，用less命令显示文件时，PageUp键向上翻页，PageDown键向下翻页，要退出less程序，应按Q键。</p>
<p>less的作用与more十分相似，不同点为less命令允许用户向前或向后浏览文件，而more命令只能向前浏览 。</p>
<p>**语法格式：**less [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>置缓冲区的大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>当文件显示结束后，自动离开</td>
</tr>
<tr>
<td>-f</td>
<td>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</td>
</tr>
<tr>
<td>-g</td>
<td>只标志最后搜索的关键词</td>
</tr>
<tr>
<td>-i</td>
<td>忽略搜索时的大小写</td>
</tr>
<tr>
<td>-m</td>
<td>显示类似more命令的百分比</td>
</tr>
<tr>
<td>-N</td>
<td>显示每行的行号</td>
</tr>
<tr>
<td>-o</td>
<td>将less 输出的内容在指定文件中保存起来</td>
</tr>
<tr>
<td>-Q</td>
<td>不使用警告音</td>
</tr>
<tr>
<td>-s</td>
<td>显示连续空行为一行</td>
</tr>
<tr>
<td>-S</td>
<td>在单行显示较长的内容，而不换行显示</td>
</tr>
<tr>
<td>-x</td>
<td>将TAB字符显示为指定个数的空格字符</td>
</tr>
</tbody>
</table>
<h3 id="8-cmp命令-–-比较两个文件是否有差异">8.cmp命令 – 比较两个文件是否有差异</h3>
<p>cmp命令有用于比较两个任意类型的文件，若两个文件相同则默认不输出任何信息，若两个文件不同，则会输出第一个不同之处的字符和列数编号，结果输出到标准输出。</p>
<p>若不指定任何文件名称或是所给予的文件名为”-“，则cmp命令会从标准输入设备读取数据。</p>
<p>**语法格式：**cmp [参数] [文件] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>–help</th>
<th>显示帮助</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v/–version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-s/–quit/–silent</td>
<td>不显示错误信息</td>
</tr>
<tr>
<td>-l/–verbose</td>
<td>标示出所有不一样的地方</td>
</tr>
<tr>
<td>-i/–ignore-initial</td>
<td>指定一个数目</td>
</tr>
<tr>
<td>-c/–print-chars</td>
<td>除了标明差异处的十进制字码之外，一并显示该字符所对应字符</td>
</tr>
</tbody>
</table>
<h3 id="9-cut命令-–-连接文件并打印到标准输出设备上">9.cut命令 – 连接文件并打印到标准输出设备上</h3>
<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>
<p>如果不指定 File 参数，cut 命令将读取标准输入。<strong>必须指定 -b、-c 或 -f 标志之一</strong>。</p>
<p>**语法格式：**cut [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>以字节为单位进行分割 ,仅显示行中指定直接范围的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>以字符为单位进行分割 , 仅显示行中指定范围的字符</td>
</tr>
<tr>
<td>-d</td>
<td>自定义分隔符，默认为制表符”TAB”</td>
</tr>
<tr>
<td>-f</td>
<td>显示指定字段的内容 , 与-d一起使用</td>
</tr>
<tr>
<td>-n</td>
<td>取消分割多字节字符</td>
</tr>
<tr>
<td>–complement</td>
<td>补足被选择的字节、字符或字段</td>
</tr>
<tr>
<td>–out-delimiter</td>
<td>指定输出内容是的字段分割符</td>
</tr>
</tbody>
</table>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#截取每一行字符@之前的内容</span></span><br><span class="line">cut -f1 -d@ temp.txt</span><br></pre></td></tr></table></figure></div>
<h3 id="10-ln命令-–-为文件创建链接">10.ln命令 – 为文件创建链接</h3>
<p>ln命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是hard link，又称为硬链接；另一种是symbolic link，又称为符号链接。</p>
<p>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式。</p>
<p>符号链接 ：</p>
<ul>
<li>\1. 符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li>
<li>\2. 符号链接可以跨文件系统 ，硬链接不可以。</li>
<li>\3. 符号链接可以对一个不存在的文件名进行链接，硬链接不可以。</li>
<li>\4. 符号链接可以对目录进行链接，硬链接不可以。</li>
</ul>
<p>硬链接：</p>
<ul>
<li>1.硬链接以文件副本的形式存在，但不占用实际空间。</li>
<li>\2. 硬链接不允许给目录创建硬链接。</li>
<li>3.硬链接只有在同一个文件系统中才能创建。</li>
</ul>
<p><strong>语法格式：</strong> ln [参数] [源文件或目录] [目标文件或目录]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>为每个已存在的目标文件创建备份文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>此选项允许“root”用户建立目录的硬链接</td>
</tr>
<tr>
<td>-f</td>
<td>强制创建链接，即使目标文件已经存在</td>
</tr>
<tr>
<td>-n</td>
<td>把指向目录的符号链接视为一个普通文件</td>
</tr>
<tr>
<td>-i</td>
<td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td>
</tr>
<tr>
<td>-s</td>
<td>对源文件建立符号链接，而非硬链接</td>
</tr>
<tr>
<td>-v</td>
<td>详细信息模式，输出指令的详细执行过程</td>
</tr>
</tbody>
</table>
<h3 id="11-stat命令-–-显示文件状态信息">11.stat命令 – 显示文件状态信息</h3>
<p>stat命令用来显示文件或文件系统的详细信息</p>
<p>**语法格式：**stat [参数]</p>
<p><strong>常用参数</strong>：</p>
<table>
<thead>
<tr>
<th>-L</th>
<th>支持符号链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>显示文件系统的信息</td>
</tr>
<tr>
<td>-t</td>
<td>以简洁的方式输出</td>
</tr>
<tr>
<td>–help</td>
<td>显示命令帮助信息</td>
</tr>
<tr>
<td>–version</td>
<td>显示命令版本信息</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong>:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$stat</span> temp1</span><br><span class="line">  File: temp1</span><br><span class="line">  Size: 31        	Blocks: 8          IO Block: 4096   r</span><br><span class="line">egular file</span><br><span class="line">Device: fd01h/64769d	Inode: 3947315     Links: 1</span><br><span class="line">Access: (0777/-rwxrwxrwx)  Uid: (65534/  nobody)   Gid: </span><br><span class="line">(65534/  nobody)</span><br><span class="line">Access: 2022-02-17 01:36:29.776692191 +0000</span><br><span class="line">Modify: 2021-08-05 06:30:30.695361618 +0000</span><br><span class="line">Change: 2022-02-18 09:10:21.980805785 +0000</span><br><span class="line"></span><br><span class="line"><span class="variable">$stat</span> -f temp1</span><br><span class="line">  File: <span class="string">&quot;temp1&quot;</span></span><br><span class="line">    ID: dfc1c994e62bc927 Namelen: 255     Type: ext2/ext</span><br><span class="line">3</span><br><span class="line">Block size: 4096      </span><br><span class="line">Blocks: Total: 20609447   Free: 10633624   Available: 97</span><br><span class="line">38300</span><br><span class="line">Inodes: Total: 5242880    Free: 3787340</span><br></pre></td></tr></table></figure></div>
<h3 id="12-ls命令-–-显示指定工作目录下的内容及属性信息">12.ls命令 – 显示指定工作目录下的内容及属性信息</h3>
<p>ls 命令是Linux下最常用的指令之一。ls命令为英文单词 list 的缩写，正如英文单词 list 的意思，其功能是列出指定目录下的内容及其相关属性信息。</p>
<p>默认状态下，ls命令会列出当前目录的内容。而带上参数后，我们可以用ls做更多的事情。作为最基础同时又是使用频率很高的命令，我们很有必要搞清楚ls命令的用法，那么接下来一起看看吧！</p>
<p><strong>语法格式:</strong> ls [选项] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-a</th>
<th>显示所有文件及目录 (包括以“.”开头的隐藏文件)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>使用长格式列出文件及目录信息</td>
</tr>
<tr>
<td>-r</td>
<td>将文件以相反次序显示(默认依英文字母次序)</td>
</tr>
<tr>
<td>-t</td>
<td>根据最后的修改时间排序</td>
</tr>
<tr>
<td>-A</td>
<td>同 -a ，但不列出 “.” (当前目录) 及 “…” (父目录)</td>
</tr>
<tr>
<td>-S</td>
<td>根据文件大小排序</td>
</tr>
<tr>
<td>-R</td>
<td>递归列出所有子目录</td>
</tr>
</tbody>
</table>
<h3 id="13-awk命令-–-文本和数据进行处理的编程语言">13.awk命令 – 文本和数据进行处理的编程语言</h3>
<p>awk命令是一种编程语言，用于在linux/unix下对文本和数据进行处理。</p>
<p>而且它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。</p>
<p>awk认为文件都是结构化的，也就是说都是由单 词和各种空白字符组成的，这里的“空白字符”包括 空格、Tab，以及连续的空格和Tab等。每个非空白 的部分叫做“域”，从左到右依次是第一个域、第二 个域，等等。$1,$2分别用于表示域，$0则表示全部域。</p>
<p>**语法格式：**awk [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-F</th>
<th>指定输入时用到的字段分隔符</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>自定义变量</td>
</tr>
<tr>
<td>-f</td>
<td>从脚本中读取awk命令</td>
</tr>
<tr>
<td>-m</td>
<td>对val值设置内在限制</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<ul>
<li><code>awk '&#123; print $2,$3 &#125;' file </code>打印file每行第二个和第三个字段</li>
<li><code>awk -F, '&#123; print $2,$3 &#125;' file </code>，以逗号分隔字段，打印file每行第二个和第三个字段</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可以使用substr()函数对指定域截取字符串</span><br><span class="line">cat Awd.txt | awk &#x27;&#123;print substr($1,6)&#125;&#x27; #将输出Awk.txt文件第一个域的第六个字 符到最后一个字符的内容</span><br></pre></td></tr></table></figure></div>
<h3 id="14-comm命令-–-比较两个已排过序的文件">14.comm命令 – 比较两个已排过序的文件</h3>
<p>comm命令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成3行显示：第1行仅是在第1个文件中出现过的列，第2行是仅在第2个文件中出现过的列，第3行则是在第1与第2个文件里都出现过的列。若给予的文件名称为”-“，则comm指令会从标准输入设备读取数据。</p>
<p><strong>语法格式：</strong>[参数] [文件1][文件2]</p>
<table>
<thead>
<tr>
<th>-1</th>
<th>不显示只在第1个文件里出现过的列</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2</td>
<td>不显示只在第2个文件里出现过的列</td>
</tr>
<tr>
<td>-3</td>
<td>不显示只在第1和第2个文件里出现过的列</td>
</tr>
<tr>
<td>–help</td>
<td>在线帮助</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="15-grep命令-–-强大的文本搜索工具">15.grep命令 – 强大的文本搜索工具</h3>
<p>grep是“global search regular expression and print out the line”的简称，意思是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，它也是linux使用最为广泛的命令。</p>
<p>grep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。需要注意的是：一当模式中包含了空格，务必要用双引号将其引起来。</p>
<p>linux系统支持三种形式的grep命令，大儿子就是grep，标准，模仿的代表。二儿子兴趣爱好多-egrep，简称扩展grep命令，其实和grep -E等价，支持基本和扩展的正则表达式。小儿子跑的最快-fgrep，简称快速grep命令，其实和grep -F等价，不支持正则表达式，按照字符串表面意思进行匹配。</p>
<p>简单来说，grep命令可以从文件中查找包含pattern部分字符串的行，并将该文件的路径和该行输出至屏幕</p>
<p><strong>语法格式：</strong> grep [选项]… PATTERN [FILE]…</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-i</th>
<th>搜索时，忽略大小写</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>只输出匹配行的数量</td>
</tr>
<tr>
<td>-l</td>
<td>只列出符合匹配的文件名，不列出具体的匹配行</td>
</tr>
<tr>
<td>-n</td>
<td>列出所有的匹配行，显示行号</td>
</tr>
<tr>
<td>-h</td>
<td>查询多文件时不显示文件名</td>
</tr>
<tr>
<td>-s</td>
<td>不显示不存在、没有匹配文本的错误信息</td>
</tr>
<tr>
<td>-v</td>
<td>显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td>-w</td>
<td>匹配整词</td>
</tr>
<tr>
<td>-x</td>
<td>匹配整行</td>
</tr>
<tr>
<td>-r</td>
<td>递归搜索</td>
</tr>
<tr>
<td>-q</td>
<td>禁止输出任何结果，已退出状态表示搜索是否成功</td>
</tr>
<tr>
<td>-b</td>
<td>打印匹配行距文件头部的偏移量，以字节为单位</td>
</tr>
<tr>
<td>-o</td>
<td>与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</td>
</tr>
<tr>
<td>-A&lt;显示行数&gt;</td>
<td>除了显示符合范本样式的那一列之外，并显示该行之后的内容。</td>
</tr>
<tr>
<td>-B&lt;显示行数&gt;</td>
<td>除了显示符合范本样式的那一列之外，并显示该行之前的内容。</td>
</tr>
</tbody>
</table>
<p><strong>从文件内容查找匹配指定字符串的行：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep &quot;被查找的字符串&quot; 文件名</span><br></pre></td></tr></table></figure></div>
<p>例子：在当前目录里第一级文件夹中寻找包含指定字符串的 .in 文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;thermcontact&quot; /.in</span><br></pre></td></tr></table></figure></div>
<p>从文件内容查找与正则表达式匹配的行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep –e &quot;正则表达式&quot; 文件名</span><br></pre></td></tr></table></figure></div>
<p>查找时不区分大小写：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep –i &quot;被查找的字符串&quot; 文件名</span><br></pre></td></tr></table></figure></div>
<p>查找匹配的行数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep -c &quot;被查找的字符串&quot; 文件名</span><br></pre></td></tr></table></figure></div>
<p>从文件内容查找不匹配指定字符串的行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep –v &quot;被查找的字符串&quot; 文件名</span><br></pre></td></tr></table></figure></div>
<h3 id="16-find命令-–-查找和搜索文件">16.find命令 – 查找和搜索文件</h3>
<p>find命令可以根据给定的路径和表达式查找的文件或目录。find参数选项很多，并且支持正则，功能强大。和管道结合使用可以实现复杂的功能，是系统管理者和普通用户必须掌握的命令。</p>
<p><strong>find如不加任何参数，表示查找当前路径下的所有文件和目录</strong>，如果服务器负载比较高尽量不要在高峰期使用find命令，find命令模糊搜索还是比较消耗系统资源的。</p>
<p><strong>语法格式</strong>：find [路径] [参数]  [查找和搜索范围]</p>
<p><strong>常用参数</strong>：</p>
<table>
<thead>
<tr>
<th>-name</th>
<th>按名称查找 “*.c”</th>
</tr>
</thead>
<tbody>
<tr>
<td>-size</td>
<td>按大小查找  (0   +1M大于1M)</td>
</tr>
<tr>
<td>-user</td>
<td>按属性查找</td>
</tr>
<tr>
<td>-type</td>
<td>按类型查找 (d: 目录   f: 一般文件   l: 符号连结)</td>
</tr>
<tr>
<td>-iname</td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>使用find命令并加上-name选项可以在当前目录下递归地查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find</span><br><span class="line">用法：find -name 文件名 </span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<p>例子</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.c&quot;</span> <span class="comment">#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:</span></span><br></pre></td></tr></table></figure></div>
<h3 id="17-let命令-–-执行一个或多个表达式">17.let命令 – 执行一个或多个表达式</h3>
<p>let命令是bash中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p>
<p><strong>语法格式：</strong> let [参数]</p>
<p>例子:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="string">&quot;j=6+2&quot;</span> <span class="comment">#等价于((j=6+2))</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$j</span></span><br><span class="line">6 <span class="comment">#输出</span></span><br></pre></td></tr></table></figure></div>
<p>let使用C语言算术表达式语法</p>
<h3 id="18-fold命令-–-限制文件列宽">18.fold命令 – 限制文件列宽</h3>
<p>fold命令会从指定的文件里读取内容，将超过限定列宽的列加入增列字符后（就是换行），输出到标准输出设备。若不指定任何文件名称，或是所给予的文件名为”-“，则fold指令会从标准输入设备读取数据。</p>
<p>**语法格式：**fold [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>以Byte为单位计算列宽，而非采用行数编号为单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s</td>
<td>以空格字符作为换列点</td>
</tr>
<tr>
<td>-w</td>
<td>设置每列的最大行数</td>
</tr>
<tr>
<td>–help</td>
<td>在线帮助</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="19-sed命令-–-处理编辑文本文件">19.sed命令 – 处理编辑文本文件</h3>
<p>Linux sed 命令是利用脚本来处理文本文件。sed 可依照脚本的指令来处理、编辑文本文件。sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<p><strong>sed表达式通常用单引号来引用。不过也可以使用双引号</strong>。shell会在调用sed前先扩展双引号中的内容。如果想在sed表达式中使用变量，双引号就能派上用场了</p>
<p>**语法格式：**sed [参数] [文本文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-e或–expression=&lt;script&gt;</th>
<th>以选项中指定的script来处理输入的文本文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f&lt;script文件&gt;或–file=&lt;script文件&gt;</td>
<td>以选项中指定的script文件来处理输入的文本文件</td>
</tr>
<tr>
<td>-h或–help</td>
<td>显示帮助</td>
</tr>
<tr>
<td>-n或–quiet或–silent</td>
<td>仅显示script处理后的结果</td>
</tr>
<tr>
<td>-V或–version</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<ul>
<li>sed使用命令行参数</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/&quot;</span><span class="variable">$2</span><span class="string">&quot;/&quot;</span><span class="variable">$3</span><span class="string">&quot;/g&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="comment">#$1,$2,$3是命令行参数</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>-e</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;s/this/That/g&#x27;</span> - e <span class="string">&#x27;s/line/LINE/g&#x27;</span> Sed.txt <span class="comment">#使用-e 参数和分号连接多编辑命令 #两个编辑命令前都要使用-e 参数，如果有更多的编辑需求，以此类推即可</span></span><br></pre></td></tr></table></figure></div>
<p><strong>&lt;script&gt;中动作说明</strong></p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/Empty/d&#x27;</span> Sed.txt <span class="comment">#删除所有包含Empty 的行</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> Sed.txt <span class="comment">#删除空行</span></span><br><span class="line">sed <span class="string">&#x27;5!d&#x27;</span> Sed.txt <span class="comment">#删除除指定范围以外的行（只保留第5 行）</span></span><br><span class="line">sed <span class="string">&#x27;1,$d&#x27;</span> Sed.txt <span class="comment">#删除指定范围的行（第一行到最后行）</span></span><br><span class="line"><span class="comment">#如果想直接修改文件，使用-i</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed -n &#x27;s/the/THE/p&#x27; Sed.txt #使用p 命令，则只打印实际处理过的行，简化了输出（使用-n 参数）</span></span><br><span class="line"><span class="comment">#####this is line 2, THE Second line, Empty line followed</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### /#g标记可以使sed替换第N次出现的匹配：</span></span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">&#x27;s/this/THIS/2g&#x27;</span> </span><br><span class="line">thisTHISTHISTHIS </span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">&#x27;s/this/THIS/3g&#x27;</span> </span><br><span class="line">thisthisTHISTHIS </span><br><span class="line">$ <span class="built_in">echo</span> thisthisthisthis | sed <span class="string">&#x27;s/this/THIS/4g&#x27;</span> </span><br><span class="line">thisthisthisTHIS</span><br></pre></td></tr></table></figure></div>
<h4 id="sed例子"><a class="link" href="https://www.runoob.com/linux/linux-comm-sed.html">sed例子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4>
<h3 id="20-nl命令-添加行号">20.nl命令-添加行号</h3>
<p>nl命令是一个很好用的编号过滤工具。该命令可以读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。</p>
<p>**语法格式：**nl [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>指定行号指定的方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>列出行号表示的方式</td>
</tr>
<tr>
<td>-w</td>
<td>行号栏位的占用的位数</td>
</tr>
<tr>
<td>-p</td>
<td>在逻辑定界符处不重新开始计算。</td>
</tr>
</tbody>
</table>
<h3 id="21-expr命令-–-命令行计数器">21.expr命令 – 命令行计数器</h3>
<p>expr命令的英文全称是“expression”，即是表达式的意思，作用是一个命令行的计数器，常用于在UNIX/LINUX系统中求表达式变量的值，一般用于整数值，也可用于字符串。</p>
<p>**语法格式：**expr [表达式]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>空格</th>
<th>隔开每个项</th>
</tr>
</thead>
<tbody>
<tr>
<td>\（反斜杠）</td>
<td>放在 shell 特定的字符前面</td>
</tr>
<tr>
<td>“”(引号)</td>
<td>对包含空格和其他特殊字符的字符串要用引号括起来</td>
</tr>
</tbody>
</table>
<p><strong>参考实例</strong></p>
<ul>
<li><a class="link" href="https://www.cnblogs.com/chengjian-physique/p/8878341.html">正则表达式匹配 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>:</li>
</ul>
<p><strong>“string : REGEX&quot;字符串匹配示例。要输出匹配到的字符串结果，需要使用”(“和”)&quot;，否则返回的将是匹配到的字符串数量。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xuexi ~]# expr abcde : &#x27;ab\(.*\)&#x27;</span><br><span class="line">cde</span><br><span class="line"></span><br><span class="line">[root@xuexi ~]# expr abcde : &#x27;ab\(.\)&#x27;</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">[root@xuexi ~]# expr abcde : &#x27;ab.*&#x27;  </span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">[root@xuexi ~]# expr abcde : &#x27;ab.&#x27;   </span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">[root@xuexi ~]# expr abcde : &#x27;.*cd*&#x27;</span><br><span class="line">4</span><br></pre></td></tr></table></figure></div>
<h5 id="注意，由于REGEX中隐含了-，所以使得匹配时都是从string首字符开始的。">注意，由于REGEX中隐含了&quot;^&quot;，所以使得匹配时都是从string首字符开始的。</h5>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xuexi ~]# expr abcde : &#x27;cd.*&#x27;  </span><br><span class="line">0</span><br></pre></td></tr></table></figure></div>
<p>之所以为0，是因为真正的正则表达式是&quot;^cd.*&quot;，而abcde不是c开头而是a开头的，所以无法匹配到任何结果。因此，任何字符串匹配时，都应该从首字符开始。</p>
<p>字符串匹配时，会先将两端参数转换为字符格式。</p>
<ul>
<li>
<h5 id="计算字串长度：">计算字串长度：</h5>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# expr length “this is a test”  </span><br><span class="line">14 </span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<h5 id="抓取字串（substr-string-pos-len）：">抓取字串（<strong>substr string pos len</strong>）：</h5>
</li>
</ul>
<p>该表达式是从string中取出从pos位置开始长度为len的子字符串。如果pos或len为非正整数时，将返回空字符串。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# expr substr “this is a test” 3 5 </span><br><span class="line">is is</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<h5 id="抓取第一个字符数字串出现的位置（index-string-chars）：">抓取第一个字符数字串出现的位置（<strong>index string chars</strong>）：</h5>
</li>
</ul>
<p>该表达式是从string中搜索chars中某个字符的位置，这个字符是string中最靠前的字符</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# expr index &quot;sarasara&quot; a </span><br><span class="line">2</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<h5 id="整数运算：">整数运算：</h5>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# expr 14 % 9</span><br><span class="line">5  </span><br><span class="line">[root@linuxcool ~]# expr 10 + 10</span><br><span class="line">20</span><br><span class="line">[root@linuxcool ~]# expr 1000 + 900</span><br><span class="line">1900</span><br><span class="line">[root@linuxcool ~]# expr 30 / 3 / 2</span><br><span class="line">5</span><br><span class="line">[root@linuxcool ~]# expr 30 * 3  </span><br><span class="line">expr: Syntax error  </span><br><span class="line">[root@linuxcool ~]# expr 30 /* 3 </span><br><span class="line">90</span><br></pre></td></tr></table></figure></div>
<p>注意：使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义</p>
<ul>
<li>
<h5 id="使用expr进行四则运算：">使用expr进行四则运算：</h5>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# expr \( 10 + 10 \) \* 2 + 100 </span><br><span class="line">140</span><br></pre></td></tr></table></figure></div>
<h3 id="22-sort命令-–-排序文件并输出">22.sort命令 – 排序文件并输出</h3>
<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p>
<p>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出</p>
<p>**语法格式：**sort [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-b</th>
<th>忽略每行前面开始出的空格字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>检查文件是否已经按照顺序排序</td>
</tr>
<tr>
<td>-d</td>
<td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符</td>
</tr>
<tr>
<td>-f</td>
<td>排序时，将小写字母视为大写字母</td>
</tr>
<tr>
<td>-i</td>
<td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符</td>
</tr>
<tr>
<td>-m</td>
<td>将几个排序号的文件进行合并</td>
</tr>
<tr>
<td>-M</td>
<td>将前面3个字母依照月份的缩写进行排序</td>
</tr>
<tr>
<td>-n</td>
<td>依照数值的大小排序</td>
</tr>
<tr>
<td>-o &lt;输出文件&gt;</td>
<td>将排序后的结果存入制定的文件</td>
</tr>
<tr>
<td>-r</td>
<td>以相反的顺序来排序</td>
</tr>
<tr>
<td>-t &lt;分隔字符&gt;</td>
<td>指定排序时所用的栏位分隔字符</td>
</tr>
<tr>
<td>-k</td>
<td>指定需要排序的栏位 -k 2 根据第二列拍排     -k 2, 4根据第二到四列排</td>
</tr>
<tr>
<td>-u</td>
<td>忽略相同行</td>
</tr>
</tbody>
</table>
<h3 id="23-uniq命令-–-去除文件中的重复行">23.uniq命令 – 去除文件中的重复行</h3>
<p>uniq命令全称是“unique”，中文释义是“独特的，唯一的”。该命令的作用是用来去除文本文件中连续的重复行，中间不能夹杂其他文本行。去除了重复的，保留的都是唯一的，也就是独特的，唯一的了。</p>
<p>我们应当注意的是，它和sort的区别，sort只要有重复行，它就去除，而uniq重复行必须要连续，也可以用它忽略文件中的重复行。</p>
<p>**语法格式：**uniq [参数] [文件]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-c</th>
<th>打印每行在文本中重复出现的次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>只显示有重复的纪录，每个重复纪录只出现一次</td>
</tr>
<tr>
<td>-u</td>
<td>只显示没有重复的纪录</td>
</tr>
</tbody>
</table>
<h3 id="24-tr命令-–-字符转换">24.tr命令 – 字符转换</h3>
<p>tr的英文全称是“ transform ”，即转换的意思。该命令的作用是一种可将字符进行替换、压缩、删除，他可以将一组字符转换成另一组字符。tr他只能从标准输入中读取数据，因此，tr要么将输入文件重定向到标准输入，要么从管道读入数据。</p>
<p>注意：tr类似于sed命令，但是比sed简单，所以tr能实现的功能，sed都能实现。</p>
<p>**语法格式：**tr [参数] [字符串1] [字符串2]</p>
<table>
<thead>
<tr>
<th>-c</th>
<th>选定字符串1中字符集的补集，即反选字符串1的补集</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>删除字符串1中出现的所有字符</td>
</tr>
<tr>
<td>-s</td>
<td>删除所有重复出现的字符序列，只保留一个</td>
</tr>
</tbody>
</table>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cat Words.txt| tr -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">the</span><br><span class="line">day</span><br><span class="line">is</span><br><span class="line">sunny</span><br><span class="line">the</span><br><span class="line">the</span><br><span class="line">the</span><br><span class="line">sunny</span><br><span class="line">is</span><br><span class="line">is</span><br></pre></td></tr></table></figure></div>
<h3 id="25-打印命令">25.打印命令</h3>
<ul>
<li>指定打印前几行：<strong>$ head -n 4 file</strong>  该命令会打印出文件的前4行。</li>
<li>打印最后5行：<strong>$ tail -n 5 file</strong></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>OS预习</title>
    <url>/2022/03/05/OS%E9%A2%84%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="《IDT-R30xx-Family-Software-Reference-Manual》阅读笔记">《<strong>IDT R30xx Family Software Reference Manual</strong>》阅读笔记</h2>
<table>
<thead>
<tr>
<th>CP0寄存器</th>
<th>作用</th>
<th>CP0编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>SR</td>
<td>（状态寄存器）CPU模式标志</td>
<td>12</td>
</tr>
<tr>
<td>Cause</td>
<td>描述最近识别的异常</td>
<td>13</td>
</tr>
<tr>
<td>EPC</td>
<td>来自trap的返回地址</td>
<td>14</td>
</tr>
<tr>
<td>BadVaddr</td>
<td>包含导致trap的最后一个无效程序地址。它是由各种地址错误设置的，即使没有MMU</td>
<td>8</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h3 id="SR">SR</h3>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5COS%E9%A2%84%E4%B9%A0%5Cimage-20220303213254529.png" alt="image-20220303213254529"></p>
<table>
<thead>
<tr>
<th>标记位</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CU3 CU2</td>
<td>位（31：30）分别控制“协同处理器”3和2的可用性。在R30xx系列中，如果软件希望使用BrCond（3：2）输入引脚进行轮询，或加快异常解码的速度，则可以启用这些功能。</td>
</tr>
<tr>
<td>CU1</td>
<td>“协同处理器1可用”：1使用FPA，0禁用。当值为0时，所有FPA指令都会导致异常，即使是对内核。即使有可用的FPA，关闭FPA也是有用的；如果打算使用BrCond（1）pin作为轮询输入，它也可以在不包含FPA的设备中启用。</td>
</tr>
<tr>
<td>CU0</td>
<td>“协同处理器0可用”：设置1为能够在用户模式下使用一些名义上的特权指令（这很少这样做）。编码为“协处理器0”类型的CPU控制指令在内核模式下始终可用，无论此位的设置如何。</td>
</tr>
<tr>
<td>RE</td>
<td>“在用户模式下反转环境”。MIPS处理器可以在重置时配置“环境性”(字节排序约定，在各种CPU的用户手册和本手册后面讨论)。RE位允许使用一个字节排序约定运行的二进制文件在约定相反的系统中运行，假设操作系统软件提供了必要的支持。当RE处于活动状态时，用户特权软件运行就像CPU配置了相反的环境一样。然而，实现跨宇宙运行也需要大量的软件工作，而且在嵌入式系统中应该不是必要的。</td>
</tr>
<tr>
<td>BEV</td>
<td>“引导异常向量”：当BEV==1时，CPU使用ROM(kseg1)空间异常入口点（在后面的章节中描述）。在正在运行的系统中，BEV通常被设置为零；这将重新定位异常向量。对RAM地址，加速访问并允许使用“用户提供的”异常服务例程。</td>
</tr>
<tr>
<td>TS</td>
<td>“TLB关闭”：在实现完整的R3000AMMU的设备中，如果一个程序地址同时匹配两个TLB条目，则TS将被设置。在某些实现中，在这种状态下的长时间操作可能会导致内部争用和损坏芯片。TLB关机是终端，只能通过硬件重置来清除。在不包括TLB的基本家族成员中，此位通过重置来设置；软件可以依赖此功能来确定是否存在TLB支持硬件。</td>
</tr>
<tr>
<td>PE</td>
<td>如果发生了缓存奇偶校验错误，请进行设置。这种情况不会产生异常，而这实际上只对诊断有用。MIPS体系结构具有缓存诊断功能，因为CPU的早期版本使用了外部缓存，这提供了一种验证特定系统的时间安排的方法。对于这些实现，缓存奇偶校验错误位是一个必要的设计调试工具。对于具有片上缓存的cpu，很少需要这一特性；只有R3071和R3081对片上缓存实现奇偶校验。</td>
</tr>
<tr>
<td>CM</td>
<td>显示使用隔离的Dcache执行的最后一次加载操作的结果（见缓存管理章节所述）。如果缓存确实包含寻址内存位置的数据（即：即使缓存没有被隔离，负载也会在缓存中命中），则设置CM</td>
</tr>
<tr>
<td>PZ</td>
<td>设置时，缓存奇偶校验位被写为零，不检查。这在需要外部缓存ram的旧R3000A系统中很有用，但与R30xx家族没有什么关系。</td>
</tr>
<tr>
<td>SwC,IsC</td>
<td>“交换缓存“”和“”隔离（数据）缓存“”。用于缓存管理和诊断的缓存模式位；它们的使用将在后面的缓存管理章节中有详细介绍。简单地说：<br>IsC设置1：使所有加载和存储只访问数据缓存，而不访问内存；在这种模式下，部分字存储会使缓存条目无效。注意，当设置此位时，即使在总线上也看不到未缓存的数据访问；此外，此位不会通过重置进行初始化。引导软件必须确保在依赖外部数据引用之前正确地初始化这个位。<br>SwCset1：反转I-缓存和D-缓存的角色，以便软件可以访问并使I-缓存条目无效。</td>
</tr>
<tr>
<td>IM</td>
<td>“中断掩码”：一个8位字段，定义在激活时哪个中断源可以导致异常。其中6个中断源是外部引脚(一个可以被FPA使用，尽管它生活在同一芯片上，但在逻辑上是外部的)；另外两个是原因寄存器中的软件可写的中断位。CPU不提供中断优先级：硬件处理所有中断位都相同。这将在处理异常的章节中进行更详细的描述。</td>
</tr>
<tr>
<td>KUc,IEc</td>
<td>两个基本的CPU保护位。<br>当使用内核权限运行时，KUc设置为1，用户模式设置为0。在内核模式下，软件可以获取整个程序地址空间，并使用特权（“协同处理器0”）指令。用户模式限制软件的程序地址在0x0000 0000 和0x7FFFFFFF之间，并且可以拒绝运行特权指令的权限；尝试违反规则会导致异常。<br>IEc被设置为0，以防止CPU采取任何中断，并通过1来启用。</td>
</tr>
<tr>
<td>KUp, IEp</td>
<td>“KU previous, IE previous”<br>在异常下，硬件取KUc和IEc的值并保存在这里；同时将KUc、IEc的值更改为[1,0]（内核模式，禁用中断）。指令rfe可用于将KUp、IEp复制回KUc、IEc。</td>
</tr>
<tr>
<td>KUo, IEo</td>
<td>‘‘KU old, IE old’’<br>在一个异常下，KUp，IEp位被保存在这里。实际上，6个KU/IE位被作为一个3深、2位宽的堆栈操作，它在一个异常上推送并被rfe弹出。这提供了从异常处理例程中早期发生的异常中干净恢复的机会，因此第一个异常尚未保存SR。可以做到这一点的情况是有限的，而且它可能只在允许用户TLB重新填充代码变得更短方面真正有用，如内存管理一章所述。</td>
</tr>
</tbody>
</table>
<h3 id="Cause-Register">Cause Register</h3>
<p><img lazyload src="/images/loading.svg" data-src="E:%5C%E5%BE%85%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5COS%E9%A2%84%E4%B9%A0%5Cimage-20220303215119767.png" alt="image-20220303215119767"></p>
<p>Cause寄存器中的字段”显示了原因寄存器中的字段，通过查阅这些字段来确定所发生的异常的类型，并将用于决定要调用哪个异常例程。</p>
<table>
<thead>
<tr>
<th>标记位</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>BD</td>
<td>“分支延迟”：如果设置，此位表示EPC不指向实际的“异常”指令，而是指向它之前的分支指令。当异常重启点是位于分支后面的“延迟槽”中的指令时，EPC必须指向分支指令；重新执行该分支是无害的，但是如果CPU从异常返回到分支延迟指令本身，该分支将不会被接受，异常将破坏中断的程序。软件可能对这一位敏感的唯一时间是，如果它必须分析“违规”指令(如果BD==1，那么该指令是在EPC+4)。如果需要模拟该指令（例如，没有硬件FPA的设备中的浮点指令；或放置在分支延迟槽中的断点），则会发生这种情况。</td>
</tr>
<tr>
<td>CE</td>
<td>“协处理器错误“”：如果因为“协处理器”格式指令对应的“协处理器”在SR中的CUx位没有启用而发生异常，则此字段具有该指令的协处理器号</td>
</tr>
<tr>
<td>IP</td>
<td>“中断待定”：显示当前断言的中断（但可能被“屏蔽”，无法实际发出异常信号）。这些位遵循六个硬件级别的CPU输入。位9和位8是可读/可写的，并包含最后一次写入它们的值。然而，当被适当的IM位和SR中的全局中断启用标志IEc启用时，激活的8位中的任何一个都会导致中断。IP与其他原因寄存器字段有细微的不同；它并不指示异常发生时发生了什么，而是显示现在发生了什么。</td>
</tr>
<tr>
<td>ExcCode</td>
<td>一种5位代码，它指示发生了什么类型的异常</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>ExcCode Value</th>
<th>Mnemonic （助记符）</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Int</td>
<td>Interrupt</td>
</tr>
<tr>
<td>1</td>
<td>Mod</td>
<td>‘TLB modifification’’ <br>（“TLB修改”）</td>
</tr>
<tr>
<td>2</td>
<td>TLBL</td>
<td>TLB load</td>
</tr>
<tr>
<td>3</td>
<td>TLBS</td>
<td>TLB store</td>
</tr>
<tr>
<td>4</td>
<td>AdEL</td>
<td>地址错误（在加载或存储时）。在用户模式下尝试访问kuseg外部，或者试图在一个不对齐的地址上读取一个单词或半单词</td>
</tr>
<tr>
<td>5</td>
<td>AdES</td>
<td>地址错误（在读取或存储时）。在用户模式下尝试访问kuseg外部，或者试图在一个不对齐的地址上读取一个单词或半单词</td>
</tr>
<tr>
<td>6</td>
<td>IBE</td>
<td>总线错误（指令获取）。外部硬件发出了某种错误的信号。适当的异常处理是依赖于系统的。R30xx系列CPU不能在存储时发生总线错误。R30xx系列CPU在存储时不能接受总线错误。写入缓冲器会使这种异常 “不精确”。</td>
</tr>
<tr>
<td>7</td>
<td>DBE</td>
<td>总线错误（数据加载）。外部硬件发出了某种错误的信号。适当的异常处理是依赖于系统的。R30xx系列CPU不能在存储时发生总线错误。R30xx系列CPU在存储时不能接受总线错误。写入缓冲器会使这种异常 “不精确”。</td>
</tr>
<tr>
<td>8</td>
<td>Syscall</td>
<td>由系统切换指令无条件生成的</td>
</tr>
<tr>
<td>9</td>
<td>Bp</td>
<td>Breakpoint - a break instruction. <br>中断指令</td>
</tr>
<tr>
<td>10</td>
<td>RI</td>
<td>reserved instruction<br>保留指令</td>
</tr>
<tr>
<td>11</td>
<td>CpU</td>
<td>Co-Processor unusable<br>协处理器无法使用</td>
</tr>
<tr>
<td>12</td>
<td>Ov</td>
<td>算术溢出’'。请注意，&quot;无符号 &quot;版本的指令（例如addu）从来不会引起这种异常。</td>
</tr>
</tbody>
</table>
<h3 id="EPC-Register">EPC Register</h3>
<p>这是一个32位的寄存器，包含这个异常的返回点的32位地址。的32位地址。导致（或遭受）异常的指令在EPC，除非BD在Cause中被设置，在这种情况下EPC指向前一条(分支)指令。</p>
<h3 id="BadVaddr-Register">BadVaddr Register</h3>
<p>一个32位的寄存器，包含了导致异常的地址；在任何与MMU相关的异常中，当用户程序试图访问kuseg以外的地址时，或者当一个地址被错误地对齐了所引用的数据量时，都会被设置。在任何其他异常情况下，这个寄存器都是未定义的。特别要注意的是 它在总线错误后不会被设置。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell学习笔记</title>
    <url>/2022/03/06/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="SHELL编程">SHELL编程</h2>
<h3 id="零碎知识点-2">零碎知识点</h3>
<ul>
<li><code>echo -e &quot;lbh666\tyzsb&quot;</code>  -e使字符串可以转义</li>
<li><code>printf</code>命令类似C语言，<code>printf &quot;%d %d&quot; 1 2</code></li>
</ul>
<span id="more"></span>
<h3 id="1-输入-输出重定向">1.输入/输出重定向</h3>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">command &gt; file</td>
<td style="text-align:left">将输出重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">command &lt; file</td>
<td style="text-align:left">将输入重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">command &gt;&gt; file</td>
<td style="text-align:left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt; file</td>
<td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt;&gt; file</td>
<td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td style="text-align:left">n &gt;&amp; m</td>
<td style="text-align:left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td style="text-align:left">n &lt;&amp; m</td>
<td style="text-align:left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt; tag</td>
<td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<p>如 0 &gt; file就是把标准输入重定向到file</p>
<p><code>$ gcc m1.c 2&gt; errfile</code>表示把编译的错误信息重定向到文件errfile中，注意2与定向符&quot;&gt;&quot;之间不能有空格</p>
</blockquote>
<blockquote>
<p>&lt;&lt;tag用法:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ wc -l &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">lbh666</span></span><br><span class="line"><span class="string">666lbh</span></span><br><span class="line"><span class="string">lbhlbh</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">3          <span class="comment"># 输出结果为 3 行</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure></div>
<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>
<h3 id="2-引号">2.引号</h3>
<ul>
<li>
<p>双引号</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
<li>
<p>单引号:由单引号括起来的字符都作为普通字符出现</p>
<ul>
<li>单引号字符串的限制：
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>倒引号`</p>
<ul>
<li>括起来的字符串被shell解释为命令行，将命令行执行结果替换原来被括起来的字符串</li>
<li>可以嵌套使用，内层的`需要用\转义</li>
</ul>
</li>
</ul>
<h3 id="3-管道线">3.管道线</h3>
<p><strong>定义</strong>:管道线是由&quot;|&quot;隔开的若干命令组成的序列，每个命令执行时有独立的进程，前一个命令的输出是下一个命令的输入</p>
<p><strong>例子</strong>:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ls | grep m.\.c | wc -l</span><br></pre></td></tr></table></figure></div>
<p>统计当前目录中文名以m打头，后随一个字符所有C语言文件的数目</p>
<h3 id="4-变量">4.变量</h3>
<p><strong>变量名和等号之间不能有空格</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;tom&quot;</span> <span class="comment">#定义变量 变量名和等号之间不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span><span class="comment"># 使用一个定义过的变量，只要在变量名前面加美元符号即可</span></span><br><span class="line">your_name=<span class="string">&quot;alibaba&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span> <span class="comment">#花括号是为了帮助解释器识别变量的边界 echo &quot;$&#123;your_name&#125;aafaf&quot;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="变量类型">变量类型</h4>
<p>运行shell时，会同时存在三种变量：</p>
<ul>
<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h3 id="5-Shell-数组">5.Shell 数组</h3>
<h4 id="定义-2">定义</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure></div>
<p>单独定义数组的各个分量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure></div>
<h4 id="读取数组">读取数组</h4>
<p>${数组名[下标]}</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125; #取第n位元素</span><br><span class="line">echo $&#123;array_name[@]&#125; #取所有元素</span><br><span class="line">length=$&#123;#array_name[@]&#125; # 取得数组元素的个数</span><br></pre></td></tr></table></figure></div>
<h3 id="6-Shell-传递参数">6.Shell 传递参数</h3>
<p>在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，其中 <strong>$0</strong> 为执行的文件名，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数。$1、$2 … $n&quot;的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。 如@用括起来的情况、以&quot;$1&quot;  $2&quot; … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<h3 id="7-Shell运算">7.Shell运算</h3>
<p>使用expr</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">val=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;两数之和为 : <span class="variable">$val</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 <strong>`</strong> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加法</td>
<td style="text-align:left"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减法</td>
<td style="text-align:left"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘法</td>
<td style="text-align:left"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除法</td>
<td style="text-align:left"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取余</td>
<td style="text-align:left"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">a=$b 把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">相等。用于比较两个数字，相同则返回 true。</td>
<td style="text-align:left">[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td style="text-align:left">[ $a != $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<h4 id="关系运算符">关系运算符</h4>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">检测两个数是否相等，相等返回 true。</td>
<td style="text-align:left">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">检测两个数是否不相等，不相等返回 true。</td>
<td style="text-align:left">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td style="text-align:left">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td style="text-align:left">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td style="text-align:left">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td style="text-align:left">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="8-Shell-流程控制">8.Shell 流程控制</h3>
<p>条件判断一般用[[]]   如if [[ $a &gt; $b]]</p>
<h4 id="8-1-if-else-if-else">8.1 if else-if else</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></div>
<h4 id="8-2-for-循环">8.2 for 循环</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div>
<p>例子</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The value is: <span class="variable">$loop</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>
<h4 id="8-3-while-语句">8.3 while 语句</h4>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>
<h4 id="8-4-跳出循环">8.4 跳出循环</h4>
<p>break跳出所有循环</p>
<p>continue跳出当前循环</p>
<h3 id="9-Shell-函数">9.Shell 函数</h3>
<h4 id="格式">格式</h4>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>说明：</p>
<ul>
<li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li>
</ul>
<h4 id="函数参数">函数参数</h4>
<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过$n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数,当n&gt;=10时，需要使用${n}来获取参数</p>
<h5 id="例子-2">例子</h5>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2023/01/23/Trie%E6%A0%91/</url>
    <content><![CDATA[<h3 id="基本思想">基本思想</h3>
<p>高效地存储和查找字符串集合的数据结构，存储的字母或者数字种类不能太多</p>
<span id="more"></span>
<p>存储ABD AC ABE可以表示为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    B--&gt;E;</span><br></pre></td></tr></table></figure></div>
<p>在单词结尾打标记，如上面的D E C，以便知道树根到当前节点是不是一个单词</p>
<h3 id="模板">模板</h3>
<h4 id="Trie字符串统计">Trie字符串统计</h4>
<p>维护一个字符串集合，支持两种操作：</p>
<ol>
<li><code>I x</code> 向集合中插入一个字符串 x；</li>
<li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p>共有 N个操作，所有输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含整数 N，表示操作数。</p>
<p>接下来 N 行，每行包含一个操作指令，指令为 <code>I x</code> 或 <code>Q x</code> 中的一种。</p>
<h4 id="输出格式">输出格式</h4>
<p>对于每个询问指令 <code>Q x</code>，都要输出一个整数作为结果，表示 x 在集合中出现的次数。</p>
<p>每个结果占一行。</p>
<h4 id="数据范围">数据范围</h4>
<p>1≤N≤2∗1041≤N≤2∗104</p>
<h4 id="输入样例：">输入样例：</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure></div>
<h4 id="输出样例：">输出样例：</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> ss[N];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][t]) &#123;</span><br><span class="line">            trie[p][t] = ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        p = trie[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[p][t]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = trie[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, ss);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(ss);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(ss) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习</title>
    <url>/2022/02/27/Vim%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Vim模式">Vim模式</h2>
<p>Vim 具有 6 种基本模式和 5 种派生模式，先学三种</p>
<ul>
<li>普通模式(Normal mode)</li>
</ul>
<p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是 Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p>
<ul>
<li>插入模式(Insert mode)</li>
</ul>
<p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p>
<blockquote>
<p>在插入模式中，可以按 <code>ESC</code> 键回到普通模式。</p>
</blockquote>
<ul>
<li>命令行模式(Command line mode)</li>
</ul>
<blockquote>
<p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（<code>:</code>键），搜索（<code>/</code>和<code>?</code>键）或者过滤命令（<code>!</code>键）。在命令执行之后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p>
</blockquote>
<span id="more"></span>
<h2 id="编辑基本操作">编辑基本操作</h2>
<ul>
<li>
<p>Esc键进入普通模式</p>
</li>
<li>
<p>命令行模式中输入 <code>wq</code> 回车后保存并退出 vim</p>
</li>
<li>
<p><code>:</code> 进入命令行模式，输入 <code>w</code> 回车，保存文档，输入 <code>:w &lt;filename&gt;</code> 可以将文档另存为其他文件名或存到其它路径下。</p>
</li>
<li>
<p>命令行模式后输入 <code>:e &lt;filepath&gt;</code> 可以打开相应文件</p>
</li>
<li>
<p>按下 <code>i</code> 键进入插入模式</p>
</li>
<li>
<p>普通模式下</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code></td>
<td>左</td>
</tr>
<tr>
<td><code>l</code></td>
<td>右（小写 L）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>下</td>
</tr>
<tr>
<td><code>k</code></td>
<td>上</td>
</tr>
<tr>
<td><code>w</code></td>
<td>移动到下一个单词</td>
</tr>
<tr>
<td><code>b</code></td>
<td>移动到上一个单词</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>在当前光标处进行编辑</td>
</tr>
<tr>
<td><code>I</code></td>
<td>在行首插入</td>
</tr>
<tr>
<td><code>A</code></td>
<td>在行末插入</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td><code>O</code></td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="退出vim">退出vim</h3>
<p><strong>从普通模式输入 <code>:</code> 进入命令行模式，输入 <code>wq</code> 回车，保存并退出编辑。</strong>（先掌握这个）</p>
<p>以下为其它几种退出方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:q!</code></td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>:wq!</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:w &lt;文件路径&gt;</code></td>
<td>另存为</td>
</tr>
<tr>
<td><code>:saveas 文件路径</code></td>
<td>另存为</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
</tbody>
</table>
<h4 id="普通模式下退出-vim">普通模式下退出 vim</h4>
<p>普通模式下按下 <code>Shift+zz</code> 即可保存退出 vim。</p>
<h3 id="删除文本">删除文本</h3>
<p>进入普通模式，使用下列命令可以进行文本快速删除：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同 <code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词（不适用中文）</td>
</tr>
<tr>
<td><code>d$</code>或<code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删至文档首部</td>
</tr>
</tbody>
</table>
<p>除此之外，可以在命令之前加上数字，表示一次删除多行，如：</p>
<p><code>2dd</code> 表示一次删除 2 行</p>
<p><code>d2w</code>表示删两个单词</p>
<h3 id="vim-重复命令">vim 重复命令</h3>
<ul>
<li>普通模式下 <code>.</code>(小数点)表示重复上一次的命令操作</li>
<li>普通模式输入 <code>N&lt;command&gt;</code>，N 表示重复后面的次数，表示重复几次命令</li>
</ul>
<h3 id="游标的快速跳转">游标的快速跳转</h3>
<h4 id="行间跳转">行间跳转</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nG</code>(n Shift+g) / <code>ngg</code></td>
<td>游标移动到第 n 行 <strong>(如果默认没有显示行号，请先进入命令模式，输入 <code>:set nu</code> 以显示行号)</strong></td>
</tr>
<tr>
<td><code>gg</code></td>
<td>游标移动到到第一行</td>
</tr>
<tr>
<td><code>G</code>(Shift+g)</td>
<td>到最后一行</td>
</tr>
</tbody>
</table>
<p><strong>小技巧：你在完成依次跳转后，可以使用 <code>Ctrl+o</code> 快速回到上一次(跳转前)光标所在位置</strong></p>
<h4 id="行内跳转">行内跳转</h4>
<p>普通模式下使用下列命令在行内按照单词为单位进行跳转：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>w</code></td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>到当前单词的结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td><code>0</code>或<code>^</code></td>
<td>到行头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>到行尾</td>
</tr>
<tr>
<td><code>f&lt;字母&gt;</code></td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td>
</tr>
<tr>
<td><code>F&lt;字母&gt;</code></td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td><code>t&lt;字母&gt;</code></td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td>
</tr>
<tr>
<td><code>T&lt;字母&gt;</code></td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td>
</tr>
</tbody>
</table>
<h3 id="复制粘贴和剪切">复制粘贴和剪切</h3>
<h4 id="复制及粘贴文本">复制及粘贴文本</h4>
<ul>
<li>普通模式中使用 <code>y</code> 复制</li>
<li>普通模式中，<code>yy</code> 复制游标所在的整行（<code>3yy</code> 表示复制 3 行）</li>
<li>普通模式中，<code>y^</code> 复制至行首，或 <code>y0</code>。不含光标所在处字符。</li>
<li>普通模式中，<code>y$</code> 复制至行尾。含光标所在处字符。</li>
<li>普通模式中，<code>yw</code> 复制一个单词。</li>
<li>普通模式中，<code>y2w</code> 复制两个单词。</li>
<li>普通模式中，<code>yG</code> 复制至文本末。</li>
<li>普通模式中，<code>y1G</code> 复制至文本开头。</li>
<li>普通模式中使用 <code>p</code> 粘贴</li>
<li>普通模式中，<code>p</code>(小写)代表粘贴至光标后（下）</li>
<li>普通模式中，<code>P</code>(大写)代表粘贴至光标前（上）</li>
</ul>
<h4 id="剪切及粘贴">剪切及粘贴</h4>
<p>其实 <code>dd</code> 删除命令就是剪切，每次 <code>dd</code> 删除文档内容后，便可以使用 <code>p</code> 来粘贴，也这一点可以实现一个很爽快的功能——交换上下行。</p>
<p><code>ddp</code>，就这么简单，即实现了快速交换光标所在行与它下面的行。</p>
<h2 id="Vim-查找替换">Vim 查找替换</h2>
<h3 id="字符的替换及撤销-Undo-操作">字符的替换及撤销(Undo 操作)</h3>
<h4 id="替换和撤销-Undo-命令">替换和撤销(Undo)命令</h4>
<p>替换和 Undo 命令都是针对普通模式下的操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code>+&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td><code>R</code></td>
<td>连续替换，直到按下 <code>Esc</code></td>
</tr>
<tr>
<td><code>cc</code></td>
<td>替换整行，即删除游标所在行，并进入插入模式</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换一个单词，即删除一个单词，并进入插入模式</td>
</tr>
<tr>
<td><code>C</code>(大写)</td>
<td>替换游标以后至行末</td>
</tr>
<tr>
<td><code>~</code></td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td><code>&#123;n&#125;u</code></td>
<td>撤销一次或 n 次操作</td>
</tr>
<tr>
<td><code>U</code>(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>redo，即撤销 undo 的操作</td>
</tr>
</tbody>
</table>
<h3 id="快速缩进">快速缩进</h3>
<ul>
<li>普通模式下输入 <code>&gt;&gt;</code> 整行将向右缩进（用于格式化代码）</li>
<li>普通模式下输入 <code>&lt;&lt;</code> 整行向左回退</li>
<li>普通模式下输入 <code>:</code> 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数</li>
</ul>
<p>获取目前的设定值：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> shiftwidth?</span><br></pre></td></tr></table></figure></div>
<p>设置缩进为 4 个字符：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> shiftwidth=4</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>set ts=4</code>设置tab缩进为4格</li>
</ul>
<h4 id="调整文本位置">调整文本位置</h4>
<p>命令行模式下输入 <code>:ce</code>(center)命令使本行内容居中：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">:ce</span><br></pre></td></tr></table></figure></div>
<p>命令行模式下输入 <code>:ri</code>(right)命令使本行文本靠右：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">:ri</span><br></pre></td></tr></table></figure></div>
<p>命令行模式下输入 <code>le</code>(left)命令使本行内容靠左：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">:le</span><br></pre></td></tr></table></figure></div>
<h3 id="查找">查找</h3>
<h4 id="快速查找">快速查找</h4>
<p>普通模式下输入 <code>/</code> 然后键入需要查找的字符串，按回车后就会进行查找。<code>?</code> 与<code>/</code> 功能相同，只不过 <code>?</code> 是向上而 <code>/</code> 是向下查找。</p>
<p>进入查找之后，输入 <code>n</code> 和 <code>N</code> 可以继续查找。<code>n</code> 是查找下一个内容，<code>N</code> 查找上一个内容。</p>
<p>命令行模式下输入 <code>noh</code> 然后回车即可取消搜索</p>
<h4 id="高级查找">高级查找</h4>
<ul>
<li>普通模式下输入 <code>\*</code> 寻找游标所在处的单词</li>
<li>普通模式下输入 <code>\#</code> 同上，但 <code>\#</code> 是向前（上）找，<code>\*</code> 则是向后（下）找</li>
<li>普通模式下输入 <code>g\*</code> 同 <code>\*</code>，但部分符合该单词即可</li>
<li>普通模式下输入 <code>g\#</code> 同 <code>\#</code>，但部分符合该单词即可</li>
</ul>
<h4 id="功能设置">功能设置</h4>
<ul>
<li>
<p>命令行模式下输入 <code>: set cindent(cin)</code> 设置 C 语言风格缩进</p>
</li>
<li>
<p>命令行模式下输入 <code>:set</code> 或者 <code>:se</code> 显示所有修改过的配置</p>
</li>
<li>
<p>命令行模式下输入 <code>:set autoindent(ai)</code> 设置自动缩进</p>
</li>
<li>
<p><code>:set nu</code>（显示行数）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc学习</title>
    <url>/2022/03/05/gcc%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="过程">过程</h2>
<p>C 或者 C++ 程序从源代码生成可执行程序的过程，需经历 4 个过程，分别是预处理、编译、汇编和链接</p>
<h3 id="参数">参数</h3>
<h4 id="gcc-E">gcc -E</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-E（大写）	预处理指定的源文件，不进行编译。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>gcc -E 指令只会将预处理操作的结果输出到屏幕上，并不会自动保存到某个文件。因此该指令往往会和 -o 选项连用，将结果导入到指令的文件中</li>
</ul>
<span id="more"></span>
<h4 id="gcc-S">gcc -S</h4>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-S（大写）	编译指定的源文件，但是不进行汇编。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>
<p>gcc 指令添加 -S（注意是大写）选项，即可令 GCC 编译器仅将指定文件加工至编译阶段，并生成对应的汇编代码文件</p>
</li>
<li>
<p>经过执行 gcc -S 指令，其生成了一个名为 demo.s 的文件，这就是经过编译的汇编代码文件。也就是说默认情况下，编译操作会自行新建一个文件名和指定文件相同、后缀名为 .s 的文件，并将编译的结果保存在该文件中。</p>
</li>
<li>
<p>如果需要的话，我们还可以为 gcc -S 指令添加 -o 选项，令 GCC 编译器将编译结果保存在我们指定的文件中</p>
</li>
<li>
<p>gcc -S 指令可以操作预处理后的 .i 文件，也可以操作源代码文件</p>
<ul>
<li>
<pre><code>gcc -S demo.i -o test.i
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​				如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；</span><br><span class="line"></span><br><span class="line">​				如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行预处理和编译这 2 步操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### gcc -c</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>-c	编译、汇编指定的源文件，但是不进行链接。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">需要强调的一点是，和 gcc -S 类似，gcc -c 选项并非只能用于加工 .s 文件。事实上，-c 选项只是令 GCC 编译器将指定文件加工至汇编阶段，但不执行链接操作。这也就意味着：</span><br><span class="line"></span><br><span class="line">- 如果指定文件为源程序文件（例如 demo.c），则 gcc -c 指令会对 demo.c 文件执行预处理、编译以及汇编这 3 步操作；</span><br><span class="line">- 如果指定文件为刚刚经过预处理后的文件（例如 demo.i），则 gcc -c 指令对 demo.i 文件执行编译和汇编这 2 步操作；</span><br><span class="line">- 如果指定文件为刚刚经过编译后的文件（例如 demo.s），则 gcc -c 指令只对 demo.s 文件执行汇编这 1 步操作</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>gcc a.c #进行上述三个操作并连接，生成可执行文件a.out<br>
gcc a.c b.c c.c -o test.out#一起编译连接三个文件，生成一个可执行文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### gcc -o</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>-o	指定生成文件的文件名。<br>
##example<br>
gcc -E demo.c -o demo.i</p>
<pre><code>


#### gcc -I 

指定头文件位置，相对路径和绝对路径都可以
</code></pre>
]]></content>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>java数据结构模板</title>
    <url>/2022/02/04/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="变长数组">变长数组</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span><span class="comment">//返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span><span class="comment">//返回从索引fromIndex到toIndex的元素集合，包左不包右</span></span></span><br></pre></td></tr></table></figure></div>
<span id="more"></span>
<h3 id="队列">队列</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;E&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">offer(e)     <span class="comment">//进队列，将元素加入队列末尾</span></span><br><span class="line">poll()         <span class="comment">//获取队列头的元素并移除</span></span><br><span class="line">peek()        <span class="comment">//获取队列头的元素</span></span><br><span class="line">isEmpty() <span class="comment">//判断是否为空</span></span><br></pre></td></tr></table></figure></div>
<h3 id="堆（小根堆）">堆（小根堆）</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;E&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">minHeap.offer();<span class="comment">//插入</span></span><br><span class="line">minHeap.poll();<span class="comment">//弹出堆顶元素</span></span><br><span class="line">minHeap.isEmpty();</span><br><span class="line"><span class="comment">//可用自定义比较实现大根堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1, Integer num2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num1 &gt;= num2 ? -<span class="number">1</span> : <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<h3 id="栈">栈</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;E&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stack.push()<span class="comment">//addFirst()</span></span><br><span class="line">stack.pop()<span class="comment">//removeFri==irst()</span></span><br><span class="line">stack.peek()<span class="comment">//peekFirst()</span></span><br><span class="line"><span class="comment">//注意元素是头插入，按输入顺序输出时要逆序输出</span></span><br></pre></td></tr></table></figure></div>
<h3 id="哈希表">哈希表</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;K, V&gt; eleMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//可用匿名内部类初始化</span></span><br><span class="line">eleMap.put(K,V);</span><br><span class="line">eleMap.get(K);</span><br><span class="line">eleMap.remove(K);</span><br><span class="line">eleMap.containskey(key)  <span class="comment">//查询集合中是否包含某个K   </span></span><br><span class="line">eleMap.containsvalue(value)  <span class="comment">//查询集合中是否包含某个value值</span></span><br><span class="line">eleMap.keySet() <span class="comment">//获取集合中所有键的集合</span></span><br><span class="line">eleMap.values()  <span class="comment">//获取集合中所有值的集合 接口为Set</span></span><br><span class="line">eleMap.entrtSet() <span class="comment">//返回Map.Entry对象,键值对</span></span><br></pre></td></tr></table></figure></div>
<h3 id="集合">集合</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;E&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add()<span class="comment">// 重复的元素不会被添加返回false，添加成功返回true</span></span><br><span class="line">set.contains()</span><br><span class="line">set.remove()<span class="comment">// 删除元素，删除成功返回 true，否则为 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="有序集合">有序集合</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;E&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">set.add();</span><br><span class="line">set.contains();</span><br><span class="line">set.remove();</span><br><span class="line"><span class="comment">//lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null</span></span><br><span class="line">set.lower();</span><br><span class="line">set.floor();</span><br><span class="line">set.ceiling();</span><br><span class="line">set.higher();</span><br></pre></td></tr></table></figure></div>
<p>待续…</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法</title>
    <url>/2022/02/19/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul>
<li>二分法的本质不是单调性而是二段性，一段满足性质，一段不满足性质。两个模板分别在满足性质的区间里寻找最左边的答案(一)和最右边的答案(二)</li>
<li>有单调性一定可以二分，能二分不一定要有单调性</li>
<li>每次二分要保证mid处于答案的区间内</li>
<li>二分模板在有解的情况用，无解下二分的输出根据题目确定</li>
</ul>
<span id="more"></span>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h6 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h6><p>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="模板一在保证有解的情况下逐步向左缩小区间"><a href="#模板一在保证有解的情况下逐步向左缩小区间" class="headerlink" title="模板一在保证有解的情况下逐步向左缩小区间"></a>模板一在保证有解的情况下逐步向左缩小区间</h5><h6 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h6><p>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;</p>
<p>此时为了防止死循环，计算mid时需要加1。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="模板二在保证有解的情况下逐步向右缩小区间"><a href="#模板二在保证有解的情况下逐步向右缩小区间" class="headerlink" title="模板二在保证有解的情况下逐步向右缩小区间"></a>模板二在保证有解的情况下逐步向右缩小区间</h5><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 3 3 3 4 4 5 用二分法寻找等于3的位置</span><br><span class="line">模板一check函数为x&gt;=3 输出3</span><br><span class="line">模板二check函数为x&lt;=3 输出5</span><br></pre></td></tr></table></figure></div>
<h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p>有for和while两种写法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h3><p>二分找一次函数的零点，三分找二次函数的极值点</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eplison = <span class="number">1e-5</span>;</span><br><span class="line"><span class="keyword">double</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans = (<span class="keyword">double</span> )<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ans += t * a[i];</span><br><span class="line">        t *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf&quot;</span>, &amp;n, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eplison) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> lmid = mid - eplison;</span><br><span class="line">        <span class="keyword">double</span> rmid = mid + eplison;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cal</span>(lmid) &gt; <span class="built_in">cal</span>(rmid)) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2022/02/19/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1>前缀和与差分</h1>
<h2 id="前缀和">前缀和</h2>
<h3 id="一维前缀和">一维前缀和</h3>
<p>s[i]代表前i个数的和</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">S[i] = a[1] + a[2] + ... a[i] //前缀和初始化,边界s[0]=0</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1] //求区间[l,r]的和，O(1)时间</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">	s[i]=s[i-1]+a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<span id="more"></span>
<h3 id="二维前缀和">二维前缀和</h3>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">		s[i][j] = s[i-<span class="number">1</span>][j] + s[i][j-<span class="number">1</span>] - s[i-<span class="number">1</span>][j-<span class="number">1</span>] + a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure></div>
<h3 id="差分">差分</h3>
<h3 id="一维差分">一维差分</h3>
<p>初始化</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b[0] = a[0]</span><br><span class="line">b[i] = a[i] - a[i-1] i&gt;0</span><br></pre></td></tr></table></figure></div>
<h5 id="给区间-l-r-中的每个数加上c：B-l-c-B-r-1-c">给区间[l, r]中的每个数加上c：<code>B[l] += c, B[r + 1] -= c</code></h5>
<p>我的理解，就是[l,]区间的数加上了c,[r+1]区间的数减了c,最后就是[l,r]加上了c,这样更好理解二维差分</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] b, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	b[l]+=c;</span><br><span class="line">	b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;<span class="comment">//[l,r]区间每个数加c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n ;i++)&#123;</span><br><span class="line">	insert(b, i, i, a[i]);</span><br><span class="line">&#125;<span class="comment">//初始化差分数组b，注意b数组大小至少为n+2;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	b[i]+=b[i-<span class="number">1</span>];</span><br><span class="line">&#125;<span class="comment">//差分数组转化为原来的数组</span></span><br></pre></td></tr></table></figure></div>
<h3 id="二维差分">二维差分</h3>
<h5 id="给以-x1-y1-为左上角，-x2-y2-为右下角的子矩阵中的所有元素加上c：S-x1-y1-c-S-x2-1-y1-c-S-x1-y2-1-c-S-x2-1-y2-1-c">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<code>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</code></h5>
<h6 id="S-x1-y1-c表示给-x1-y1-右下角矩阵所有元素加上c">S[x1, y1] += c表示给(x1,y1)右下角矩阵所有元素加上c</h6>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] b, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	b[x1][y1]+=c;</span><br><span class="line">	b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">	b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">	b[x2][y2]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">| | | |</span><br><span class="line">| | | |</span><br><span class="line">| | | |</span><br><span class="line">| | | |</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">		insert(b,i,j,i,j,a[i][j])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">		b[i][j] = b[i-<span class="number">1</span>][j] + b[i][j-<span class="number">1</span>] - b[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//使用前缀和使差分数组变为前缀和数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="完全背包问题">完全背包问题</h2>
<p>每种物品无限个</p>
<ul>
<li>
<h4 id="状态转移">状态转移</h4>
</li>
</ul>
<p>以前一直对完全背包的状态转移方程**<code>f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i])</code><strong>里面的</strong><code>f[i][j-v[i]]+w[i]</code>**似懂非懂，今天看到一个比较好的解释</p>
<p>1.已知完全背包还有状态转移方程</p>
<p><code>f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i],f[i-1][j-2*v[i]]+2*w[i],...,f[i-1][j-k*v[i]]+k*w[i])  (j-k*v[i]&gt;=0)</code></p>
<p>2.故可得<code>f[i][j-v[i]] = max(f[i-1][j-v[i]],f[i-1][j-2*v[i]]+*w[i],...,f[i-1][j-k*v[i]]+(k-1)*w[i])</code></p>
<p>3.第二步的式子左右加上w[i]，右边带入一式即可得**<code>f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i])</code>**</p>
<ul>
<li>
<h4 id="排列型背包和组合型背包">排列型背包和组合型背包</h4>
<ul>
<li>排列型背包外层循环价值，内层循环物品</li>
<li>组合型背包外层循环物品，内层循环价值</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="多重背包">多重背包</h2>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p>
<h4 id="直接拆分法">直接拆分法</h4>
<p>当成01背包做，效率低</p>
<h4 id="二进制拆分法">二进制拆分法</h4>
<p>将每种物品按二进制1,2,4,…,2^k^	,s-2^k+1^+1拆分成log(si)个，降低时间复杂度</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">k=1</span><br><span class="line">while (k &lt;= s)&#123;</span><br><span class="line">	cnt ++ ;</span><br><span class="line">	v[cnt] = a * k;</span><br><span class="line">    w[cnt] = b * k;</span><br><span class="line">    s -= k;</span><br><span class="line">    k *= 2;</span><br><span class="line">&#125;</span><br><span class="line">if (s &gt; 0)&#123;</span><br><span class="line">	cnt ++ ;</span><br><span class="line">    v[cnt] = a * s;</span><br><span class="line">    w[cnt] = b * s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="分组背包">分组背包</h2>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>
每件物品的体积是 vij，价值是 wij，其中 i是组号，j是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<h4 id="做法">做法</h4>
<p>直接三重循环，最内层循环更新第i组每个物品对应的 最优解</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i<span class="number">-1</span>][j-k] + v[i][k] &gt; f[i][j]) &#123;</span><br><span class="line">				f[i][j] =  f[i<span class="number">-1</span>][j-k] + v[i][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="背包问题输出方案">背包问题输出方案</h2>
<p>本质是最短路问题</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1007</span>, V = <span class="number">1007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][V];</span><br><span class="line"><span class="keyword">int</span> way[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span> vi = v[i], wi = w[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			f[i][j] = f[i+<span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= vi) &#123;</span><br><span class="line">				f[i][j] = max(f[i][j], f[i+<span class="number">1</span>][j- vi] + wi);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = m; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> vi = v[i], wi = w[i];</span><br><span class="line">		<span class="keyword">if</span> ( (j &gt;= vi &amp;&amp; f[i][j] == f[i+<span class="number">1</span>][j-vi] + wi)) &#123;</span><br><span class="line">			way[i] = <span class="number">1</span>;</span><br><span class="line">			j -= vi;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (way[i]) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="区间DP">区间DP</h2>
<p><strong>方法:</strong></p>
<p><strong>1.循环</strong></p>
<p>外层枚举区间长度,内层枚举左端点位置，对[l,r]区间内的序列进行dp</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len <span class="number">-1</span> &lt;= n; l ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l;k &lt; r; k++) &#123;</span><br><span class="line">            f[l][r] = max(f[l][r], f[l][k] + f[k+<span class="number">1</span>][r] + w[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>2.记忆化搜索</strong></p>
<p><strong>模型:</strong></p>
<p><strong>1.环形问题</strong></p>
<p>将环变成链，即在原本的链之后再拼接上一条链，对新的链进行dp</p>
<h2 id="状态机DP">状态机DP</h2>
<p>dp数组多加一维表示当前的状态，有点类似状态压缩dp，每次dp进行状态之间的转移(根据前一次的状态)</p>
<h2 id="状态压缩DP">状态压缩DP</h2>
<p><strong>棋盘类状压DP</strong>:用01二进制表示状态，先预处理合法的状态(减少时间复杂度)，再根据合法状态的合法转移进行dp</p>
<h2 id="树形DP">树形DP</h2>
<p>第一维通常是节点编号，多数时候用递归实现树形DP，对于每个节点x，先<strong>递归</strong>在它的每个子节点上进行DP，回溯时从子节点向节点x进行状态转移</p>
<h2 id="数位DP">数位DP</h2>
<h3 id="技巧">技巧</h3>
<p>1.[x,y]转化为[1,y] - [1,x-1]</p>
<p>2.用树的思想，考虑每一位的情况**(注意树的最右边的情况需要特判一下)**</p>
<h4 id="例题-计数问题">例题:计数问题</h4>
<p>给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数。</p>
<p>例如，a=1024，b=1032，则 a 和 b 之间共有9个数如下：</p>
<p>1024 1025 1026 1027 1028 1029 1030 1031 1032</p>
<p>其中‘0’出现10次，‘1’出现10次，‘2’出现7次，‘3’出现3次等等…</p>
<h5 id="思路">思路</h5>
<blockquote>
<p>把整个数拆成每一位，从最高位向最低位看。设当前这一位为x，则当前位分成[0,x)和x两种情况。第一种情况直接处理，剩下的就是当前位为x的情况，继续看后面的数位，重复这个操作。直到最后一位时，剩下的就是原数，判断是否符合条件即可。</p>
</blockquote>
<h5 id="技巧-2">技巧</h5>
<p>再求区间[a,b]中满足性质的数时，可以转化为求[1,b]的答案减[1,a - 1]的答案</p>
<h4 id="例题-数字游戏">例题:数字游戏</h4>
<p>由于科协里最近真的很流行数字游戏。</p>
<p>某人又命名了一种取模数，这种数字必须满足各位数字之和 mod N 为 0。</p>
<p>现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。</p>
<p><strong>输入格式</strong><br>
输入包含多组测试数据，每组数据占一行。</p>
<p>每组数据包含三个整数 a,b,N。</p>
<p><strong>输出格式</strong><br>
对于每个测试数据输出一行结果，表示区间内各位数字和 mod N 为 0 的数的个数。</p>
<p><strong>数据范围</strong><br>
1≤a,b≤231−1,<br>
1≤N&lt;100<br>
<strong>输入样例：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 19 9</span><br></pre></td></tr></table></figure></div>
<p><strong>输出样例：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">				f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">//组合数初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125; <span class="comment">//枚举数字的每一位</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//答案</span></span><br><span class="line">	<span class="keyword">int</span> last = <span class="number">0</span>; <span class="comment">//保存上一位，根据上一位来判断当前位的行为</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = nums[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = last; j &lt; x; j++) ans += f[i + <span class="number">1</span>][j];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (last &gt; x) <span class="keyword">break</span>;</span><br><span class="line">		last = x;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) ans += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">dp</span>(b) - <span class="built_in">dp</span>(a - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="计数DP">计数DP</h2>
<p>不重不漏，避免子问题重叠，通常要预处理</p>
<h2 id="闫氏DP分析法">闫氏DP分析法</h2>
<p>from:<a class="link" href="https://www.acwing.com/file_system/file/content/whole/index/content/406072/">https://www.acwing.com/file_system/file/content/whole/index/content/406072/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img lazyload src="/images/loading.svg" data-src="https://cdn.acwing.com/media/article/image/2020/03/23/27426_73d9c53a6c-2.png" alt="2png"></p>
<h4 id="dp问题的下标">dp问题的下标</h4>
<ol>
<li>若状态转移方程中有f[i - 1]这种状态, 下标(状态转移那部分代码)尽量从1开始</li>
<li>否则就最好从0开始</li>
</ol>
<h4 id="dp问题的时间复杂度">dp问题的时间复杂度</h4>
<p>状态数量(n^几个约束维度) * 转移状态的时间复杂(状态转移代码的时间复杂度)</p>
<h4 id="dp的集合划分依据-寻找最后一个不同操作">dp的集合划分依据 -&gt; 寻找最后一个不同操作</h4>
<p>eg. 加不加这个背包, 数字三角形最后一步是由左边还是右边走过来的呀(根据操作的不同来对集合进行划分)</p>
<p>使得划分之后的小集合可以<strong>递推求出当前集合, 且最小集合已知</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://cdn.acwing.com/media/article/image/2020/03/24/27426_56d0691c6d-2.png" alt="2.png"></p>
<h3 id="记忆化搜索">记忆化搜索</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br></pre></td></tr></table></figure></div>
<p>java拿Map来存比较方便且省空间</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针与滑动窗口</title>
    <url>/2022/02/19/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="双指针算法">双指针算法</h2>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>常见问题分类：<br>
(1) 对于一个序列，用两个指针维护一段区间<br>
(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<span id="more"></span>
<h2 id="滑动窗口">滑动窗口</h2>
<p><a class="link" href="https://www.cnblogs.com/powercto/p/14125370.html?ivk_sa=1024320u">https://www.cnblogs.com/powercto/p/14125370.html?ivk_sa=1024320u <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。</li>
<li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中符合要求。</li>
<li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求）。同时，每次增加 left，我们都要更新一轮结果。</li>
<li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li>
</ol>
<p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项算法</title>
    <url>/2023/01/23/%E6%9D%82%E9%A1%B9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="找树的直径"><a href="#找树的直径" class="headerlink" title="找树的直径"></a>找树的直径</h3><p>定义:树中距离最远的两点</p>
<p>1.任取一点作为起点，找到距离该点最远的一个点u</p>
<p>2.再找到距离u最远的一点v</p>
<p>u和v之间的路径就是一条直径</p>
<span id="more"></span>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>核心思想:遇到一个数，如果该数性质比栈顶元素更优，则将栈顶元素出栈，直到该数比栈顶元素性质不优为止，将该数入栈</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>核心思想:首先判断队头是否滑出窗口，遇到一个数，如果该数比队尾元素更优，则队尾元素出队，直到该数比队尾元素不优为止，将该数入队</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h2><p>把a*b转化为a+a+a+….+a(b个a相加)，利用快速幂的思想，计算出a,2*a,4*a,……2<sup>k</sup>*a，根据b的二进制位(比如9 = 0b10001),a*9 = 2<sup>0</sup>a+2<sup>4</sup>a,可以省去高精度乘法</p>
<h2 id="枚举子集"><a href="#枚举子集" class="headerlink" title="枚举子集"></a>枚举子集</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">&#123;</span><br><span class="line">    f[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=i;s;s=(s<span class="number">-1</span>)&amp;i) <span class="comment">//i是集合二进制表示,s是i的子集</span></span><br><span class="line">        <span class="keyword">if</span>(cover[s]==all)   </span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i],f[i^s]+<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>a / b向上取整</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = (a + b - <span class="number">1</span>) / b;</span><br></pre></td></tr></table></figure></div>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p><strong>核心思想</strong>：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br><strong>小技巧</strong>：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef unsigned long long ULL;</span><br><span class="line">ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">p[0] = 1;</span><br><span class="line">for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - 1] * P + str[i];</span><br><span class="line">    p[i] = p[i - 1] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="line">ULL get(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    return h[r] - h[l - 1] * p[r - l + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h2><p>康托展开可以用来求一个$1\sim n$ 的任意排列的排名</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        t[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="built_in">add</span>(a);</span><br><span class="line">        <span class="keyword">int</span> tt = a - <span class="built_in">query</span>(a);</span><br><span class="line">        ans += f[n - i - <span class="number">1</span>] * tt;</span><br><span class="line">        ans %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>逆康托定理，求n的全排列中排名第k的排列</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> jc[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        jc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            jc[i] = jc[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k / jc[n - i];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, num = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == t + <span class="number">1</span>) &#123;</span><br><span class="line">                    f[j] = <span class="number">1</span>;</span><br><span class="line">                    num = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="string">&#x27;0&#x27;</span> + num;</span><br><span class="line">            k -= t * jc[n - i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="区间平均数"><a href="#区间平均数" class="headerlink" title="区间平均数"></a>区间平均数</h3><p>看到这种和区间平均数有关的题目可以考虑把每个数减去平均数M，一段区间的平均数大于M等价于减完数后区间的区间和大于零          </p>
<h3 id="一个正整数n被拆分为k个正整数，k-gt-2，求这k个整数乘积最大是多少"><a href="#一个正整数n被拆分为k个正整数，k-gt-2，求这k个整数乘积最大是多少" class="headerlink" title="一个正整数n被拆分为k个正整数，k&gt;=2，求这k个整数乘积最大是多少"></a>一个正整数n被拆分为k个正整数，k&gt;=2，求这k个整数乘积最大是多少</h3><p>尽可能多分解3</p>
<p><a class="link" href="https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/">https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="如何比枚举n的约数更快求出n的所有约数"><a href="#如何比枚举n的约数更快求出n的所有约数" class="headerlink" title="如何比枚举n的约数更快求出n的所有约数"></a>如何比枚举n的约数更快求出n的所有约数</h3><p>如果直接枚举，那么时间复杂度是根号N。可以先求出2~n内的素数，然后枚举素数判断是否是n的约数，时间复杂度是$\frac{n}{\ln(n)}$，然后dfs将{素数,出现次数}还原为n的约数</p>
<p><a class="link" href="https://www.acwing.com/problem/content/description/202/">https://www.acwing.com/problem/content/description/202/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树与图算法</title>
    <url>/2022/02/19/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h1><p>考的是怎么从题目条件抽象出图(建图)</p>
<h2 id="树与图存储"><a href="#树与图存储" class="headerlink" title="树与图存储"></a>树与图存储</h2><h4 id="邻接表（前向星）"><a href="#邻接表（前向星）" class="headerlink" title="邻接表（前向星）"></a>邻接表（前向星）</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点，e[k]存储箭头指向的点,we[k]存储该边权值</span><br><span class="line">int h[N], e[N], ne[N],we[N] idx;</span><br><span class="line"></span><br><span class="line">// 添加一条边a-&gt;b z为权值</span><br><span class="line">void add(int a, int b, int z)</span><br><span class="line">&#123;</span><br><span class="line">    we[idx] = z, e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">idx = 0;</span><br><span class="line">memset(h, -1, sizeof h);</span><br></pre></td></tr></table></figure></div>
<p>对于每个顶点，添加与其相连的边时按照头插法添加,</p>
<span id="more"></span>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    st[u] = true; // st[u] 表示点u已经被遍历过</span><br><span class="line"></span><br><span class="line">    for (int i = h[u]; i != -1; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        if (!st[j]) dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h5 id="时间复杂度-O-n-m-n-表示点数，m-表示边数"><a href="#时间复杂度-O-n-m-n-表示点数，m-表示边数" class="headerlink" title="时间复杂度 O(n+m), n 表示点数，m 表示边数"></a>时间复杂度 O(n+m), n 表示点数，m 表示边数</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h3><p><img lazyload src="/images/loading.svg" data-src="E:\待更新博客\新建文件夹\树与图算法\6828_6fb1dd8eda-最短路.jpg" alt="6828_6fb1dd8eda-最短路"></p>
<h4 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h4><h5 id="时间复杂是-O-n2-m-n-表示点数，m-表示边数"><a href="#时间复杂是-O-n2-m-n-表示点数，m-表示边数" class="headerlink" title="时间复杂是 O(n2+m), n 表示点数，m 表示边数"></a>时间复杂是 O(n2+m), n 表示点数，m 表示边数</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">507</span>][<span class="number">507</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">507</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">507</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">507</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(g[i], <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            st[t] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dist[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] we = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        we[idx] = z;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HeapDijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];&#125;);</span><br><span class="line">        heap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = heap.poll();</span><br><span class="line">            <span class="keyword">int</span> ver = cur[<span class="number">0</span>], distance = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (st[ver]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st[ver] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != -<span class="number">1</span>; i=ne[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span> (dist[j] &gt; distance + we[i]) &#123;</span><br><span class="line">                    dist[j] = distance + we[i];</span><br><span class="line">                    heap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;j, dist[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h4><p>时间复杂度是 O(n3), n 表示点数</p>
<p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Floyd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">211</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        k = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), z = in.nextInt();</span><br><span class="line">            d[x][y] = Math.min(d[x][y], z);</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (d[x][y] &gt; <span class="number">0x3f3f3f3f</span> &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(d[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><h5 id="时间复杂度-O-nm-n表示点数，m表示边数"><a href="#时间复杂度-O-nm-n表示点数，m表示边数" class="headerlink" title="时间复杂度 O(nm), n表示点数，m表示边数"></a>时间复杂度 O(nm), n表示点数，m表示边数</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 边，<span class="title">a</span>表示出点，<span class="title">b</span>表示入点，<span class="title">w</span>表示边的权重</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br></pre></td></tr></table></figure></div>
<h4 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">507</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        k = in.nextInt();</span><br><span class="line">        edge[] edges = <span class="keyword">new</span> edge[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), z = in.nextInt();</span><br><span class="line">            edges[i] = <span class="keyword">new</span> edge(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = bellmanFord(edges);</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bellmanFord</span><span class="params">(edge[] edges)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] copy = Arrays.copyOf(dist,N);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">                dist[b] = Math.min(dist[b], copy[a] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="spfa-算法求最短路（队列优化的Bellman-Ford算法）"><a href="#spfa-算法求最短路（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法求最短路（队列优化的Bellman-Ford算法）"></a>spfa 算法求最短路（队列优化的Bellman-Ford算法）</h4><h5 id="关于入队"><a href="#关于入队" class="headerlink" title="关于入队"></a>关于入队</h5><blockquote>
<p>接下来由que[head]开始拓展，一旦发现新的路线（dst[que[head]]+w[i]）比原来的（dst[son[i]]）优秀就修正，如果vis[son[i]]==false，也就是说son[i]不在队列中，当然就是入队了，但是如果son[i]在队列中，要不要入队呢？显然不需要。但是如果入队了也不会影响答案。为什么不需要入队呢？（可能你的疑问是：在修正后面这个son[i]的时候，可能会更优秀啊？）因为如果son[i]已经在队列中，那么说明以后一定会再从son[i]开始修正，那么问题就是从上一个son[i]之后到这个son[i]之前这一段，会不会导致后面能修正出更优秀的son[i]？显然这不需要考虑，因为<strong>如果更优秀，之后还是会重新把son[i]修正/入队的</strong>！所以，这个时候son[i]就不要入队，因为入队无疑会浪费时间和空间。</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>Java</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spfa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] we = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        we[idx] = z;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), z = in.nextInt();</span><br><span class="line">            add(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = spfa();</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = que.poll();</span><br><span class="line">            st[t] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = e[i];</span><br><span class="line">                <span class="keyword">if</span> (dist[b] &gt; dist[t] + we[i]) &#123;</span><br><span class="line">                    dist[b] = dist[t] + we[i];</span><br><span class="line">                    <span class="keyword">if</span> (!st[b]) &#123;</span><br><span class="line">                        st[b] = <span class="keyword">true</span>;</span><br><span class="line">                        que.offer(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h4><h5 id="时间复杂度是-O-nm-n-表示点数，m-表示边数"><a href="#时间复杂度是-O-nm-n-表示点数，m-表示边数" class="headerlink" title="时间复杂度是 O(nm),n 表示点数，m 表示边数"></a>时间复杂度是 O(nm),n 表示点数，m 表示边数</h5><p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpfaMinWay</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] we = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        we[idx] = z;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), z = in.nextInt();</span><br><span class="line">            add(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spfa()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            que.offer(i);</span><br><span class="line">            st[i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = que.poll();</span><br><span class="line">            st[t] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = e[i];</span><br><span class="line">                <span class="keyword">if</span> (dist[b] &gt; dist[t] + we[i]) &#123;</span><br><span class="line">                    dist[b] = dist[t] + we[i];</span><br><span class="line">                    count[b] = count[t]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count[b] &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!st[b]) &#123;</span><br><span class="line">                        st[b] = <span class="keyword">true</span>;</span><br><span class="line">                        que.offer(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>判断正环和判断负环类似</p>
<p><a class="link" href="https://blog.51cto.com/u_15067244/3900260">https://blog.51cto.com/u_15067244/3900260 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="朴素版prim算法"><a href="#朴素版prim算法" class="headerlink" title="朴素版prim算法"></a>朴素版prim算法</h3><h5 id="时间复杂度是-O-n2-m-n表示点数，m表示边数"><a href="#时间复杂度是-O-n2-m-n表示点数，m表示边数" class="headerlink" title="时间复杂度是 O(n2+m), n表示点数，m表示边数"></a>时间复杂度是 O(n2+m), n表示点数，m表示边数</h5><p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(g[i], <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), z = in.nextInt();</span><br><span class="line">            g[x][y] = g[y][x] =  Math.min(g[x][y], z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = prim();</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st[t] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[t] == <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dist[t];</span><br><span class="line">            &#125;</span><br><span class="line">            res += dist[t];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dist[j] = Math.min(dist[j], g[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度是 O(mlogm), n表示点数，m表示边数</p>
<p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] edge = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">            p[x] = find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt(), w = in.nextInt();</span><br><span class="line">            edge[i] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x, y, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = kruskal();</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">0</span>] &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(ans[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kruskal() &#123;</span><br><span class="line">        Arrays.sort(edge, <span class="number">0</span>, m, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[i][<span class="number">0</span>], b = edge[i][<span class="number">1</span>], w = edge[i][<span class="number">2</span>];</span><br><span class="line">            a = find(a);</span><br><span class="line">            b = find(b);</span><br><span class="line">            <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">                p[a] = b;</span><br><span class="line">                cnt++;</span><br><span class="line">                res += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;cnt, res&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p><strong>二分图当且仅当图中不含有奇数环</strong></p>
<h4 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h4><p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">erfentuRanSe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(color, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        color[a] = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[a]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (color[j] == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(j, col == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == col)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = in.nextInt(), y = in.nextInt();</span><br><span class="line">            add(x, y);</span><br><span class="line">            add(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i]==-<span class="number">1</span> &amp;&amp; !dfs(i, <span class="number">0</span>)) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h3><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>时间复杂度是 O(nm), n表示点数，m表示边数</p>
<p>C++</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>JAVA</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungarian</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n1;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] match = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(h, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                st[j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (match[j] == <span class="number">0</span> || find(match[j])) &#123;</span><br><span class="line">                    match[j] = x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n1 = in.nextInt();</span><br><span class="line">        n2 = in.nextInt();</span><br><span class="line">        m = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt(), b = in.nextInt();</span><br><span class="line">            add(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            Arrays.fill(st, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (find(i)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2023/01/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1>树状数组</h1>
<p>树状数组能处理的是下标为1~n的数组</p>
<p>考虑使用的情况：求前缀和、修改区间中的某个数，时间复杂度均为logn</p>
<h2 id="基本思想-2">基本思想</h2>
<p>将x分解为二进制x = 2<sup>i1</sup> + 2<sup>i2</sup>+…+2<sup>im</sup> (i1 &gt; … &gt; im)</p>
<p>则可以将[1,x]的区间划分为[1, 2<sup>i1</sup>],[2<sup>i1</sup>+1,2<sup>i1</sup>+2<sup>i2</sup>],[2<sup>i1</sup>+2<sup>i2</sup>+1, 2<sup>i1</sup>+2<sup>i2</sup>+2<sup>i3</sup>] …,[2<sup>i1</sup>+2<sup>i2</sup>+…+2<sup>im-1</sup> +1,2<sup>i1</sup>+2<sup>i2</sup>+…+2<sup>im</sup>  ]这些区间</p>
<p>c[x]保存序列a区间[x-lowbit(x) + 1, x]中所有数的和</p>
<p>C[i] = A[i - 2<sup>k</sup>+1] + A[i - 2<sup>k</sup>+2] + … + A[i];   //k为i的二进制中从最低位到高位连续零的长度</p>
<p><strong>该结构满足以下性质：</strong></p>
<p><strong>（1）每个内部节点c[x]保存以他为根的子树中所有叶节点的和</strong></p>
<p><strong>（2）每个内部节点c[x]的子节点数等于lowbit(x)的大小</strong></p>
<p><strong>（3）除数根外，每个内部节点c[x]的父节点是c[x+lowbit(x)]</strong></p>
<p><strong>（4）树的深度为O(logN)</strong></p>
<span id="more"></span>
<h2 id="操作">操作</h2>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lowbit(int x)&#123;</span><br><span class="line">	return x&amp; -x;</span><br><span class="line">&#125; //求x二进制下的最小的2次幂</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) t[i] += c;</span><br><span class="line">&#125;<span class="comment">//a[x] += c</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += t[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; <span class="comment">//[1,x]的和</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) add(i, a[i]);</span><br></pre></td></tr></table></figure></div>
<h2 id="应用">应用</h2>
<p>1.区间加减数，查询单点，可先差分再树状数组</p>
<p>2.区间加减数，查询区间，树状数组维护差分数组b[i]及i*b[i]，[1,x]的前缀和课用ask1(x) * (x + 1) - ask2(x)得出</p>
<p>3.找到区间[l,r]还存在的第k小的数，删除区间[1,x]中的某个数，可使原数组a[i] = 1，树状数组维护a[i]，删除x点的数使用add(x, -1)，查询[l,r]第k小的数利用ask(mid) - ask(l) &gt;= k二分</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法数学基础知识</title>
    <url>/2022/02/21/%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1.<a class="link" href="https://oi-wiki.org/math/balanced-ternary/">平衡三进制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>:mark一下，放砝码问题，梦回计组pre</p>
<p>2.一个正整数n本身和他各位之和模9同余</p>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在<strong>大于1</strong>的整数中，只包含1和本身这两个约数，就被称为质数，或者叫素数</p>
<span id="more"></span>
<h4 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="朴素筛法求素数"><a href="#朴素筛法求素数" class="headerlink" title="朴素筛法求素数"></a>朴素筛法求素数</h4><p>求2~n所有素数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化<strong>(小于x^2的x的倍数在扫描更小的数的时候已经被标记过了)</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n/i; j ++)</span><br><span class="line">            st[i*j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h4><p>保证每个数被它的最小质因子筛掉</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">//primes[j]小于等于i的最小质因子</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//保证primes[j]小于等于i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>若整数n除以整数d的余数为0，即d能整除n，则称d是n的约数,n是d的倍数</p>
<h4 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="约数个数和约数之和"><a href="#约数个数和约数之和" class="headerlink" title="约数个数和约数之和"></a>约数个数和约数之和</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck //pi为从小到大互不相同的质数</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)</span><br></pre></td></tr></table></figure></div>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>快速求得 a 和 b 的最大公约数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 欧几里得算法</span></span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="最大公约数性质"><a href="#最大公约数性质" class="headerlink" title="最大公约数性质"></a>最大公约数性质</h3><ul>
<li>a与b互质:gcd(a,b)==1</li>
</ul>
<ul>
<li>gcd(x, y)=gcd(x, y−x)</li>
<li>gcd(x, y)=gcd(y, x % y)</li>
<li>gcd(x, y) = gcd(x, -y)</li>
<li>gcd(x, 0) = x</li>
</ul>
<p>有n个数$a_1, a_2,…a_n$，gcd($a_1, a_2,…a_n$) = gcd($a_1$，gcd($a_2,…a_n$)) (结合律，证明左边式子&lt;=右边式子，右边式子&lt;=左边式子)</p>
<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>lcm(x,y) = x*y/gcd(x,y)</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>互质：$\forall a,b \in \N,若\gcd(a,b) = 1, 则a,b互质$</p>
<p><strong>对正整数m，欧拉函数是小于等于m的正整数中与m互质的数的数目.</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://bkimg.cdn.bcebos.com/formula/da74a22ed420af57afccc61bfa49eae5.svg" alt="img"></p>
<p><strong>利用容斥原理</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>性质：</p>
<p>1.$\forall n \gt 1, 1 \sim n中与n互质的数的和为n*\phi(n)/2$</p>
<p>2.$若a,b互质，则\phi(ab) = \phi(a)\phi(b)$</p>
<h3 id="筛法求欧拉函数-求2-N中每个数的欧拉函数"><a href="#筛法求欧拉函数-求2-N中每个数的欧拉函数" class="headerlink" title="筛法求欧拉函数(求2~N中每个数的欧拉函数)"></a>筛法求欧拉函数(求2~N中每个数的欧拉函数)</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="费马小定理与欧拉定理"><a href="#费马小定理与欧拉定理" class="headerlink" title="费马小定理与欧拉定理"></a>费马小定理与欧拉定理</h3><p><img lazyload src="/images/loading.svg" data-src="image-20220221110813978.png" alt="image-20220221110813978"></p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>$若整数a和整数b除以正整数m的余数相等，则称a,b模m同余，记为a \equiv b \pmod{m}$</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.若$ac \equiv bc \pmod{m}$，<strong>且c与m互质</strong>，则$a \equiv b \pmod{m}$ （两边同除c，证明欧拉定理用到）(一般形式，若$ac \equiv bc \pmod{m}$，，则$a \equiv b \pmod{m/\gcd(c,m)}$)</p>
<p>2.若$a \equiv b \pmod{m}$，且$x \equiv y \pmod{m}$，则$a + x \equiv b + y \pmod{m}$ （加法）</p>
<p>3若$a \equiv b \pmod{m}$，且$x \equiv y \pmod{m}$，则$ax \equiv by \pmod{m}$ （乘法）</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为</p>
<p><img lazyload src="/images/loading.svg" data-src="https://www.zhihu.com/equation?tex=C_%7B2n%7D%5E%7Bn%7D+-+C_%7B2n%7D%5E%7Bn%2B1%7D+%3D+%5Cfrac%7BC_%7B2n%7D%5En%7D%7Bn+%2B+1%7D" alt="[公式]"></p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p><img lazyload src="/images/loading.svg" data-src="image-20220221151638964.png" alt="image-20220221151638964"></p>
<p>如果只是保证b,m互质，乘法逆元可以通过求解同余方程$b*x \equiv 1 \pmod{m}$得到</p>
<h4 id="意义-为什么需要逆元？"><a href="#意义-为什么需要逆元？" class="headerlink" title="意义(为什么需要逆元？)"></a>意义(为什么需要逆元？)</h4><script type="math/tex; mode=display">
(a + b) \% p = (a\%p + b\%p) \%p \quad (正确)  \\

(a - b) \% p = (a\%p - b\%p) \%p \quad (正确) \\

(a * b) \% p = (a\%p * b\%p) \%p  \quad (正确) \\

(a / b) \% p = (a\%p / b\%p) \%p\quad  (错误) \\</script><p>当$a,b$很大需要取模时，如果a与b之间是除法运算，则无法像加减乘那样分开取模运算后再取模，所以需要乘法逆元</p>
<script type="math/tex; mode=display">
(a / b) \% p = (a*b^{-1}) \%p = (a\%p * b^{-1}\%p) \%p\quad  (正确)</script><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>裴蜀定理，又称贝祖定理（Bézout’s lemma）。是一个关于最大公约数的定理。</p>
<p>其内容是：设a,b是不全为零的整数，则存在整数x,y , 使得ax+by = gcd(a,b) .</p>
<p>令$d=\gcd(a,b)$对更一般的方程$ax +by=c$，它有解当且仅当$d|c$，可以先求出$ax +by=d$的一组特解$x_0,y_0$，再同时乘上$\frac{c}{d}$，得到$ax +by=c$的特解$(c/d)x_0,(c/d)y_0$，方程$ax +by=c$​的通解集合可以表示为</p>
<script type="math/tex; mode=display">
x=\frac{c}{d}x_0+k\frac{b}{d},y=\frac{c}{d}y_0-k\frac{a}{d}\quad(k \in \Z)</script><p><strong>裴蜀定理可以扩展到多个整数</strong>，设$a_1, a_2,….a_n$是$n$个整数，$d=\gcd(a_1, a_2,….a_n)$，则存在整数$x_1,x_2,…,x_n$使得$a_1<em>x_1+a_2</em>x_2+…+a_n*x_n=d$</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><h4 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h4><p>给定整数$a,b,m$,求一个整数$x$满足$a*x \equiv b \pmod{m}$，或者无解。因为未知数的指数为1，所以称为一次同余方程，也称为线性同余方程。</p>
<p>$a<em>x \equiv b \pmod{m}$等价于$a</em>x-b$是$m$的倍数，设为$-y$倍。于是方程可以改写为$a<em>x+m</em>y = b$，根据裴蜀定理可以知道方程有解当且仅当$\gcd(a,m)|b$，采用扩展欧几里得算法得出$a<em>x_0+b</em>y_0=\gcd(a,m)$的一组解$x_0,y_0$，然后$x = x_0 * b/\gcd(a,m)$，就是原线性同余方程的一组解</p>
<h4 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h4><p><strong>方程的通解是所有模$m/\gcd(a,m)$与$x$同余的整数</strong></p>
<p><strong>证明</strong>:联立下面两式</p>
<script type="math/tex; mode=display">
a*x_1+m*y_1 = b \\
a*x_2+m*y_2 = b</script><p>得</p>
<script type="math/tex; mode=display">
a*(x_1-x_2) = m*(y_2-y_1)</script><p>令$d=\gcd(a,m)$，上式两边同时除以$d$得</p>
<script type="math/tex; mode=display">
\frac{a}{d}*(x_1-x_2) = \frac{m}{d}*(y_2-y_1)</script><p>因为$d$为$a$和$m$的最大公约数，所以$\frac{a}{d}$和$\frac{m}{d}$互质，且$\frac{m}{d}|\frac{a}{d}<em>(x_1-x_2)$，所以$\frac{m}{d}|(x_1-x_2)$，得到$x_1-x_2 = k</em>m/d$，即$x_2 = x_1 + k*m/d$</p>
<h3 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h3><p>设$m_1, m_2,…,m_n$是两两互质的整数，$m=\prod_{i=1}^n m_i$，$M_i = m / m_i$,$t_i$是线性同余方程$M_it_i \equiv 1\pmod{m_i}$的一个解，对于任意的$n$个整数$a_1,a_2,…,a_n$，方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_n \pmod{m_n}
\end{cases}</script><p>有整数解，解为$x=\sum_1^{n}a_iM_it_i$</p>
<h4 id="扩展CRT"><a href="#扩展CRT" class="headerlink" title="扩展CRT"></a>扩展CRT</h4><p>如果$m_i$不两两互质，那么可以使用扩展欧几里得算法将两个式子合并成一个式子，合并n次即可得到最后答案，如</p>
<script type="math/tex; mode=display">
(a)\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\end{cases}</script><p>等价于</p>
<script type="math/tex; mode=display">
\begin{cases}
x = k_1*m_1 + a_1(3) \\
x = k_2*m_2 + a_2 \\
\end{cases}</script><p>联立可得</p>
<script type="math/tex; mode=display">
k_1*m_1 - k_2*m_2 = a_2 - a_1</script><p>有解当且仅当$\gcd(m_1, m_2)|(a_2, a_1)$，用扩展欧几里得算法可以求出$k1,k_2$特解$k’_1,k’_2$，通解为</p>
<script type="math/tex; mode=display">
\begin{cases}
k_1=k'_1 + k*\frac{m_2}{d} (1)\\
k_2=k'_2 + k'*\frac{m_1}{d}(2) \quad k,k' \in \Z \quad d=gcd(m_1, m_2)
\end{cases}</script><p>不妨将(1)式代入(3)式，可以得到$x$的通解</p>
<script type="math/tex; mode=display">
x=k'_1*m_1+a_1+k*\frac{m_1*m_2}{d}</script><p>即两个方程可以合并为一个</p>
<script type="math/tex; mode=display">
(b) \quad x \equiv k'_1*m_1+a_1 \pmod{\frac{m_1*m_2}{d}}</script><p>其中$\frac{m_1*m_2}{d} = lcm(m1, m2)$</p>
<p>为什么两个方程能合并成一个呢？只需要证明上面方程组(a)的解集与(b)相等即可，可以先设$x$是(b)的一个解，推出也是(a)的一个解，再设$x$是(a)的一个解，推出也是(b)的一个解，显然易证</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定$2n$个整数$a_1,a_2,…,a_n$和$m_1,m_2,…,m_n$，求一个最小非负整数$x$，满足$\forall i \in [1,n],x \equiv m_i \pmod{a_i}$，不存在输出$-1$</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL a1, m1, x;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        LL a2, m2;</span><br><span class="line">        cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        LL k1, k2;</span><br><span class="line">        LL d = <span class="built_in">exgcd</span>(a1, a2, k1, k2);</span><br><span class="line">        <span class="keyword">if</span> ((m2 - m1) % d) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k1 *= (m2 - m1) / d;</span><br><span class="line"></span><br><span class="line">        k1 = (k1 % (a2 / d) + a2 / d) % (a2 / d);</span><br><span class="line"></span><br><span class="line">        x = k1 * a1 + m1;</span><br><span class="line"></span><br><span class="line">        a1 = a1 / d * a2;</span><br><span class="line"></span><br><span class="line">        m1 = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x = (m1 % a1 + a1) % a1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p>
<p><strong>必胜态</strong>:可以到某一个必败态</p>
<p><strong>必败态</strong>:无论如何选取都只能到必胜态</p>
<p><strong>定理</strong>： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p>
<h4 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h4><p>若一个游戏满足：</p>
<p>1.由两名玩家交替行动；</p>
<p>2.在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br>3.不能行动的玩家判负；<br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p>
<h4 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h4><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<h4 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h4><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S</p>
<h4 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h4><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。</p>
<h4 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h4><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2023/02/01/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="单点修改区间查询"><a href="#单点修改区间查询" class="headerlink" title="单点修改区间查询"></a>单点修改区间查询</h3><h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h4><p>给定长度为$N$的数列$A$，以及$M$条指令，每条指令可能是以下两种之一：</p>
<ol>
<li><code>1 x y</code>，查询区间$[x,y]$ 中的最大连续子段和</li>
<li><code>2 x y</code>，把$A[x]$改成 $y$。</li>
</ol>
<p>对于每个查询指令，输出一个整数表示答案。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> lmax, rmax, sum, tmax;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node t[<span class="number">4</span> * N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Node&amp; root = t[u], left = t[u * <span class="number">2</span>], right = t[u * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    root.lmax = <span class="built_in">max</span>(left.lmax, left.sum + right.lmax);</span><br><span class="line">    root.rmax = <span class="built_in">max</span>(right.rmax, right.sum + left.rmax);</span><br><span class="line">    root.sum = left.sum + right.sum;</span><br><span class="line">    root.tmax = <span class="built_in">max</span>(left.tmax, <span class="built_in">max</span>(right.tmax, left.rmax + right.lmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node&amp; root, Node&amp; left, Node&amp; right)</span> </span>&#123;</span><br><span class="line">    root.lmax = <span class="built_in">max</span>(left.lmax, left.sum + right.lmax);</span><br><span class="line">    root.rmax = <span class="built_in">max</span>(right.rmax, right.sum + left.rmax);</span><br><span class="line">    root.sum = left.sum + right.sum;</span><br><span class="line">    root.tmax = <span class="built_in">max</span>(left.tmax, <span class="built_in">max</span>(right.tmax, left.rmax + right.lmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[u].sum = t[u].lmax = t[u].rmax = t[u].tmax = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[u].l &gt;= l &amp;&amp; t[u].r &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = t[u].l + t[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(u * <span class="number">2</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(u * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    Node res;</span><br><span class="line">    Node left = <span class="built_in">query</span>(u * <span class="number">2</span>, l , r);</span><br><span class="line">    Node right = <span class="built_in">query</span>(u * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[u].l == y &amp;&amp; t[u].r == y) &#123;</span><br><span class="line">        t[u].lmax = t[u].rmax = t[u].sum = t[u].tmax = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = t[u].l + t[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u * <span class="number">2</span>, y, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u * <span class="number">2</span> + <span class="number">1</span>, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="区间最大值"><a href="#区间最大值" class="headerlink" title="区间最大值"></a>区间最大值</h4><p>给定一个正整数数列$a_1,a_2,…,a_n$，每一个数都在 $0 \sim p-1$ 之间。</p>
<p>可以对这列数进行两种操作：</p>
<ol>
<li>添加操作：向序列后添加一个数，序列长度变成 $n+1$；</li>
<li>询问操作：询问这个序列中最后$L$个数中最大的数是多少。</li>
</ol>
<p>程序运行的最开始，整数序列为空。</p>
<p>一共要对整数序列进行$m$次操作。</p>
<p>写一个程序，读入操作的序列，并输出询问操作的答案</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, p, n, a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	t[u].v = <span class="built_in">max</span>(t[u &lt;&lt; <span class="number">1</span>].v, t[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r  &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l ,mid);</span><br><span class="line">	<span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t[u].l == x &amp;&amp; t[u].r == x) t[u].v = v;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">int</span> mid = t[u].l + t[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (mid &gt;= x) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= t[u].l &amp;&amp; r &gt;= t[u].r) <span class="keyword">return</span> t[u].v;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mid  = t[u].l + t[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= mid) ans = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l ,r);</span><br><span class="line">	<span class="keyword">if</span> (r &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l ,r));</span><br><span class="line">	<span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt;p;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">		<span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">			a = <span class="built_in">query</span>(<span class="number">1</span>, n - x + <span class="number">1</span>, n);</span><br><span class="line">			cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, ++n, ((LL)x + a) % p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="区间gcd"><a href="#区间gcd" class="headerlink" title="区间gcd"></a>区间gcd</h4><p>给定一个长度为 N的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<ol>
<li><code>C l r d</code>，表示把$ A[l],A[l+1],…,A[r] $都加上 。</li>
<li><code>Q l r</code>，表示询问$ A[l],A[l+1],…,A[r] $的最大公约数(GCD)。</li>
</ol>
<p>对于每个询问，输出一个整数表示答案。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL sum, d;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        LL b = w[r] - w[r - <span class="number">1</span>];</span><br><span class="line">        tr[u] = &#123;l, r, b, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        LL b = tr[u].sum + v;</span><br><span class="line">        tr[u] = &#123;x, x, b, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, l);</span><br><span class="line">            <span class="function">Node <span class="title">right</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) right = <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum, right.d)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, d);</span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(<span class="number">1</span>, r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="区间修改区间查询（懒标记）"><a href="#区间修改区间查询（懒标记）" class="headerlink" title="区间修改区间查询（懒标记）"></a>区间修改区间查询（懒标记）</h3><h4 id="区间和（区间加）"><a href="#区间和（区间加）" class="headerlink" title="区间和（区间加）"></a>区间和（区间加）</h4><p>给定一个长度为 N的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<ol>
<li><code>C l r d</code>，表示把 $A[l],A[l+1],…,A[r] $都加上 d。</li>
<li><code>Q l r</code>，表示询问数列中第 $l\sim r$个数的和。</li>
</ol>
<p>对于每个询问，输出一个整数表示答案。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125; tr[<span class="number">4</span> * N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Node &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add) &#123;</span><br><span class="line">        left.add += root.add;</span><br><span class="line">        left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add;</span><br><span class="line">        right.sum += (LL) (right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[u] = &#123;l, r, a[l], <span class="number">0</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        tr[u].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;</span><br><span class="line">        tr[u].sum += (LL) x * (tr[u].r - tr[u].l + <span class="number">1</span>);</span><br><span class="line">        tr[u].add += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l , &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="区间和（区间乘和加）"><a href="#区间和（区间乘和加）" class="headerlink" title="区间和（区间乘和加）"></a>区间和（区间乘和加）</h4><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p>
<p>有长为 N 的数列，不妨设为 $a_1,a_2,…,a_N$。</p>
<p>有如下三种操作形式：</p>
<ol>
<li>把数列中的一段数全部乘一个值；</li>
<li>把数列中的一段数全部加一个值；</li>
<li>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P的值。</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL sum, add, mul;</span><br><span class="line">&#125; tr[<span class="number">4</span> * N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> u, LL add, LL mul)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = ((LL) tr[u].sum * mul + (LL) (tr[u].r - tr[u].l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    tr[u].mul = (LL) (tr[u].mul * mul) % p;</span><br><span class="line">    tr[u].add = ((LL) (tr[u].add * mul) % p + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cal</span>(u &lt;&lt; <span class="number">1</span>, tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">cal</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[u] = &#123;l, r, a[l], <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> add, <span class="keyword">int</span> mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;</span><br><span class="line">        <span class="built_in">cal</span>(u, add, mul);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ans = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r) % p;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ans = (ans + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l , &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.区间和</p>
<p>左右子区间相加即可</p>
<p>2.区间最大数</p>
<p>左右区间最大数取max</p>
<p>3.区间最大子段和</p>
<p>左区间左端点开始的最大子段和 右区间右端点开始的最大子段和 左区间右端点开始的最大子段和+右区间左端点开始的最大子段和 三者取max</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
